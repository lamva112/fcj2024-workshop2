[
{
	"uri": "//localhost:1313/3-createecr/3.1-createfirststack/",
	"title": " Create First CloudFormation Stack",
	"tags": [],
	"description": "",
	"content": "Prepare for CDK Project Delete the Fcj2024CdkStack file that was previously created. Remove unnecessary comments from the file. Create a new stack by creating a new Java file named EcrStack.java. Using CDK, you can write code to create stacks and CloudFormation resources. Your code will be compiled into corresponding CloudFormation templates, which can then be deployed by CloudFormation as usual.\nOnce the file is created, have the EcrStack class inherit from the Stack class provided by the AWS CDK library. Create the stack constructor. Create an AWS resource through a repository: First, declare the productsServiceRepository property with the following line:\nprivate final Repository productsServiceRepository; Then initialize the productsServiceRepository property in the constructor:\nthis.productsServiceRepository = new Repository(this, \u0026#34;ProductsService\u0026#34;, RepositoryProps.builder().build()); To initialize the Repository, add the following parameters: this: Refers to the current class object (usually a CDK stack). \u0026ldquo;ProductsService\u0026rdquo;: This is the unique name (ID) of the resource being created. This name must be unique within the scope of a CDK stack. Then create the ECR Repository properties using RepositoryProps.builder().build(): builder() is a static method of the RepositoryProps class to initialize a Builder object. This is a preparation step to set properties for RepositoryProps. The build() method on the Builder object is called to finalize the construction process and return a complete RepositoryProps object with the set properties. Specify the ECR repository name by adding .repositoryName(\u0026quot;productsservice\u0026quot;) before build(). Add .removalPolicy(RemovalPolicy.DESTROY) to ensure that when the CloudFormation stack is deleted, our resources will also be deleted. Allow overriding of images in the ECR repository by enabling IMMUTABLE with imageTagMutability(TagMutability.IMMUTABLE). Enable automatic image deletion when the ECR is deleted by adding autoDeleteImages(true). Create a getter method: public Repository getProductsServiceRepository() { return productsServiceRepository; } "
},
{
	"uri": "//localhost:1313/2-prerequiste/2.1-createinfrastructureproject/",
	"title": " Creating an Infrastructure Project with AWS CDK",
	"tags": [],
	"description": "",
	"content": "Setting up an Infrastructure Project using AWS CDK Open a terminal in the directory where you want to create the project.\nEnter the following command to initialize a new AWS CDK application using Java:\ncdk init app --language java This workshop will use Java. Alternatively, you can create the project with Python or TypeScript.\nOpen IntelliJ IDEA and import the project you just created. "
},
{
	"uri": "//localhost:1313/",
	"title": "Deploy Spring Boot applications onto AWS ECS Fargate using AWS CDK.",
	"tags": [],
	"description": "",
	"content": "Deploying Spring Boot Services on AWS ECS Fargate using AWS CDK Overview In this workshop, we will create a microservice using Java 11, leveraging the Spring Boot framework, and Docker containers to build a backend application that interacts with Amazon Web Services (AWS) resources. These resources will be provisioned on AWS using the AWS Cloud Development Kit (CDK) v2, a modern way to model and configure infrastructure on AWS. AWS CDK is one of the best tools for managing infrastructure as code (IaC) on AWS.\nContent Introduction to 2-tier Prerequisite steps Create EC2 server Create RDS database Install and configure web application on EC2 server Create a highly available 2-tier web application Configure Public DNS with Route53 Clean up resources "
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "This workshop will cover the following AWS resources and tools: AWS ECS: Elastic Container Service is AWS\u0026rsquo;s container orchestration service. With ECS, you can manage the execution of Docker-based microservices efficiently and at scale. With AWS Fargate, a serverless compute engine for containers from Amazon Web Services, you don\u0026rsquo;t need to provision EC2 instances, reducing the operational cost of container-based applications.\nAWS ECR: With Elastic Container Registry (ECR) from AWS, you can create private repositories to store Docker images of your microservices.\nAWS VPC: With Virtual Private Cloud (VPC) from AWS, you can secure your infrastructure with private subnets and network security policies for inbound and outbound traffic rules.\nAWS ALB: AWS Application Load Balancer allows you to balance HTTP traffic across all available application instances, and with integrated target groups, each instance can be monitored to only receive traffic if it is operating normally.\nAPI Gateway REST: With AWS API Gateway, you can protect your application\u0026rsquo;s REST APIs and perform validation checks on query string parameters and request contents.\nCloudWatch Logs: Its responsibility is to aggregate application logs and their metrics. The applications built in this workshop will log to CloudWatch Logs in JSON format using the log4j2 library. This enables us to insert parameters into the logs for use in queries in the AWS CloudWatch Logs Insights dashboard.\nCloudWatch Alarms: With alarms from CloudWatch, you can monitor unusual events from applications and AWS resources.\nDynamoDB: DynamoDB is a powerful and non-relational NoSQL database service. This workshop introduces the usage of DynamoDB enhanced client from AWS SDK v2 for Java, which is a high-level library allowing client-side class mappings with DynamoDB tables.\nSQS: SQS is a queue service that allows asynchronous communication between applications, facilitating message and event exchanges.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.2-createspingbootproject/",
	"title": " Creating a Spring Boot Project",
	"tags": [],
	"description": "",
	"content": "Creating a Spring Boot Project Visit start.spring.io.\nChoose the programming language and framework version:\nFor Project, select Gradle - Groovy. For Language, choose Java. For Spring Boot version, select 3.2.4. Configure Project Metadata:\nSet Group to com.firstcloudjourney. Set Artifact to productsservice. Other fields will be automatically filled. Choose Java version as 21. Add Dependencies:\nClick ADD DEPENDENCIES to open a pop-up. Add Spring Web and Spring Boot Actuator packages. Generate the Spring Boot Project:\nClick GENERATE to download the created project. "
},
{
	"uri": "//localhost:1313/3-createecr/3.2-organizestack/",
	"title": " Organize CDK Stack in CDK Project",
	"tags": [],
	"description": "",
	"content": "Organize CDK Stack in CDK Project Open the root file Fcj2024CdkApp. Create an ECR Stack using the following code snippet:\nEcrStack ecrStack = new EcrStack(app, \u0026#34;Ecr\u0026#34;, StackProps.builder().build()); Create an Environment using the following code:\nEnvironment environment = Environment.builder() .account(\u0026#34;your_account_id\u0026#34;) .region(\u0026#34;ap-southeast-1\u0026#34;) .build(); Replace your_account_id with your AWS account ID. Use ap-southeast-1 as the desired AWS region for resource creation. Add the Environment to the ECRStack using the following code:\n.env(environment) Create properties infraTags for Tags:\nMap\u0026lt;String, String\u0026gt; infraTags = new HashMap\u0026lt;\u0026gt;(); infraTags.put(\u0026#34;team\u0026#34;, \u0026#34;FirstCloudJourney\u0026#34;); infraTags.put(\u0026#34;cost\u0026#34;, \u0026#34;ECommerceInfra\u0026#34;); Apply Tags to the ECRStack:\n.tags(infraTags) Check the stacks that CDK will create for CloudFormation using the command:\ncdk list Here, CDK shows that only one stack (Ecr) will be created. To prepare the deployment environment for CDK applications on AWS, including creating necessary resources for deployment and managing CDK applications effectively on the AWS platform, run the command:\ncdk bootstrap --profile default To view the resources created after running cdk bootstrap \u0026ndash;profile default, access the AWS console and navigate to CloudFormation.\nIn the CloudFormation interface, you can see a CDKToolkit stack has been created.\nSelect CDKToolkit and then choose the Resources tab to view the created resources.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/",
	"title": "Preparation Steps",
	"tags": [],
	"description": "",
	"content": "Preparation Steps Java Development Kit (JDK)\nFirstly, we need to install the Java Development Kit (JDK). In this workshop, we will use JDK 21 LTS. You can download it here. Next, we need to install Maven. You can install it following the instructions here. NodeJS\nTo install the AWS CDK CLI, we need to install NodeJS. Visit this link to download the latest LTS version.\nVerify if NodeJS is installed correctly by running the following command in the terminal:\nnode -v This command will display the installed NodeJS version:\nv18.15.0 Check the installed NPM version by running the following command in the terminal:\nnpm -v This command will display the installed NPM version:\n9.6.2 AWS CLI\nVisit this link and download the latest version of AWS CLI.\nAfter installation is complete, open a terminal and verify the installed AWS CLI version using the following command:\naws --version AWS CDK\nAWS Cloud Development Kit, or AWS CDK, will be used to build infrastructure-as-code responsible for creating the application infrastructure using AWS services.\nAfter installing the above packages, run the following command in your terminal window to install AWS CDK:\nnpm install -g aws-cdk Verify if CDK is installed correctly by running the following command in the terminal: cdk --version Postman\nPostman is a very useful free application. By using it, you can send requests to the applications developed in this workshop, whether they are running on your computer or deployed on your AWS account. Download Postman based on the instructions. IntelliJ IDEA Community Edition\nThe IDE that will be used is IntelliJ IDEA Community Edition, from JetBrains. This is one of the most modern IDEs for development in Java and other programming languages. Download IntelliJ IDEA Community Edition from this link. Docker Desktop\nDocker Desktop will be used to create Docker images of all applications to be built in this workshop before uploading the image to AWS. Download Docker via this link. "
},
{
	"uri": "//localhost:1313/3-createecr/",
	"title": " Create AWS ECR Image Repository using AWS CDK",
	"tags": [],
	"description": "",
	"content": "In this section, we will learn how to create a stack to deploy Amazon ECR on AWS.\n"
},
{
	"uri": "//localhost:1313/3-createecr/3.3-implementstack/",
	"title": " Deploy Stack to AWS ECR",
	"tags": [],
	"description": "",
	"content": "Deploy Stack to AWS ECR To deploy the stack to AWS ECR, run the following command:\ncdk deploy Ecr --profile default During the resource creation process, if prompted with security policy questions, enter y to proceed.\nThe creation of the ECR repository is successful.\nAccess the AWS console, navigate to ECR, and select Elastic Container Registry.\nYou will see that the productsservice repository has been successfully created.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.3-setupintellijidea/",
	"title": " Setting Up IntelliJ IDEA",
	"tags": [],
	"description": "",
	"content": "Setting Up IntelliJ IDEA Open IntelliJ IDEA and navigate to the Spring Boot project you just created.\nConfigure the project:\nRight-click on the project and select Open Module Settings. Under Project Settings, ensure that your project has SDK set to 21 and language level set to 21.\nUnder Platform Settings, ensure that your platform SDK is set to 21.\nRunning the Spring Boot Project Open the file application.properties and add server.port=8081 to configure the project to run on port 8081.\nClick on the Run icon to run the project. You can see the project running on port 8081.\nTesting the Project with Postman Create an HTTP GET request with the URL http://localhost:8081/actuator/health to test.\nThe response should show \u0026ldquo;status\u0026rdquo;: \u0026ldquo;UP\u0026rdquo; indicating that the project is running normally. Adding the Log4j2 Library Open the build.gradle file:\nIn the dependencies section, add the Log4j2 library with the following code: implementation \u0026#39;org.springframework.boot:spring-boot-starter-log4j2\u0026#39; Add configurations: configurations { configureEach { exclude group: \u0026#39;org.springframework.boot\u0026#39;, module: \u0026#39;spring-boot-starter-logging\u0026#39; exclude group: \u0026#39;commons-logging\u0026#39;, module: \u0026#39;commons-logging\u0026#39; } } Creating a Controller Inside the com.firstcloudjourney.productsservice directory, create a folder named products.\nInside the products folder, create a directory named controllers and create a file named ProductsController.java inside the controllers directory.\nCopy and paste the following code into ProductsController.java:\nimport org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\u0026#34;/api/products\u0026#34;) public class ProductsController { private static final Logger LOG = LogManager.getLogger(ProductsController.class); @GetMapping public String getAllProducts() { LOG.info(\u0026#34;Get all products\u0026#34;); return \u0026#34;All products\u0026#34;; } } Run the project and test with Postman by creating an HTTP GET request with the URL http://localhost:8081/api/products.\nCheck the logs returned in the terminal when making the HTTP GET request.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.4-createdockerfile/",
	"title": " Create Dockerfile and Generate Docker Image",
	"tags": [],
	"description": "",
	"content": "Create Task First, you need to create a task in the build.gradle file by copying the following code block: tasks.register(\u0026#34;unpack\u0026#34;, Copy) { dependsOn bootJar from(zipTree(tasks.bootJar.outputs.files.singleFile)) into(\u0026#34;build/libs\u0026#34;) } This code defines a Gradle task named \u0026ldquo;unpack\u0026rdquo; that copies files from a ZIP archive generated by the \u0026ldquo;bootJar\u0026rdquo; task and extracts them into the \u0026ldquo;build/libs\u0026rdquo; directory.\nCreate .dockerignore File Create a .dockerignore file to specify files and directories that Docker should ignore when building a Docker image from your project components. Copy the code below: .git .gitignore .dockerignore .gradle .idea Dockerfile README.md Create file Dockerfile Create a Dockerfile and copy the code below: FROM eclipse-temurin:21-jdk-alpine VOLUME /tmp ARG DEPENDENCY=build/libs COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib COPY ${DEPENDENCY}/META-INF /app/META-INF COPY ${DEPENDENCY}/BOOT-INF/classes /app EXPOSE 8081 ENTRYPOINT [\u0026#34;java\u0026#34;, \u0026#34;-cp\u0026#34;, \u0026#34;app:app/lib/*\u0026#34;, \u0026#34;com.firstcloudjourney.productsservice.ProductsserviceApplication\u0026#34;] Generate Docker Image Next, let\u0026rsquo;s configure IntelliJ to generate a Docker image: Click on the Run icon and select New Run Configuration. A popup will appear where we\u0026rsquo;ll configure as follows: For Image Tag, enter productsservice:1.0.0. Click Modify Options, then select Build options. Once Build options appears, enter --platform linux/amd64. Next, we need to configure Before Launch: Click the + icon and select Run Gradle Task. Then a popup will appear as shown below: In the popup for Select Gradle Task: For Gradle project, choose productsservice. For Task, select the unpack task that we added earlier. Click OK. After returning to the Edit Configuration popup, click Apply. Build Application using BootJar Next, let\u0026rsquo;s build the application using bootJar from Gradle: Click on the Gradle icon. Choose Tasks, then build, and finally click bootJar to build the application. Check the built application file located in build/libs. Generate Docker Image Now, let\u0026rsquo;s create a Docker image from the built application: Click on the Run icon on the Dockerfile and choose Build image for \u0026lsquo;DockerFile\u0026rsquo;. Make sure you have Docker Desktop running to successfully build the image.\nAfter successfully creating the image, you should see productsservice:1.0.0 generated. "
},
{
	"uri": "//localhost:1313/3-createecr/3.4-pushimage/",
	"title": " Push Docker image to ECR",
	"tags": [],
	"description": "",
	"content": "Push Docker image to ECR repository Ensure you have installed the AWS Toolkit. If not, go to IntelliJ IDEA Settings, select Plugins, and search for AWS Toolkit to install it.\nClick on the AWS Toolkit icon on the right side of IntelliJ IDEA.\nSelect profile and region:\nFor Profile, choose default. For Region, choose ap-southeast-1. Open the Explorer to view all AWS Toolkit-supported services, then select ECR.\nRight-click on the productsservice repository and choose Push to Repository\u0026hellip; to push the Docker image.\nIn the Push to ECR popup:\nFor Local Image, select productsservice:1.0.0. For ECR Repository, choose productsservice. For Remote Tag, enter 1.0.0. Finally, click Push. Check the image on ECR In the AWS Management Console, navigate to ECR.\nSelect the productsservice repository to view the Docker image version 1.0.0 that has been pushed.\n"
},
{
	"uri": "//localhost:1313/2-prerequiste/2.5-rundockerlocal/",
	"title": " Run Docker Image on Local Machine",
	"tags": [],
	"description": "",
	"content": "Run Docker Image on Local Machine Right-click on the productsservice:1.0.0 image we created earlier and select Create Container. A Docker image configuration popup will appear. Choose Run and the terminal will execute. Configure the Docker container:\nIn the Services interface, select the Dashboard tab and then click Add under Ports. A Port bindings popup will appear. Click Modify Options, then select Host IP. Enter 0.0.0.0 for the Host IP. Similarly, configure Host Port as 8081 and Protocol as TCP. For \u0026ndash;publish, enter 8081 and select Recreate container. Test Application on Postman Run the project and test on Postman by creating an HTTP GET request with the URL http://localhost:8081/api/products. "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]