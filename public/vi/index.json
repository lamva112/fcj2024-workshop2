[
{
	"uri": "//localhost:1313/vi/9-intrumentingecs/9.1-reparetousexray/",
	"title": "Chuẩn bị Productsservice Spring Boot để sử dụng AWS X-Ray",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị Productsservice Spring Boot để sử dụng AWS X-Ray Trong productsservice project. Mở file build.grade thêm x-ray sdk như sau implementation(\u0026#39;com.amazonaws:aws-xray-recorder-sdk-spring:2.14.0\u0026#39;) implementation(\u0026#39;com.amazonaws:aws-xray-recorder-sdk-aws-sdk-v2:2.14.0\u0026#39;) Trong thư mục config tạo một file mới tên là XRayConfig.java Thêm Annotation @Configuration là một annotation của Spring, cho biết lớp này sử dụng để định nghĩa các bean cho context của Spring. Tiếp đó, tạo một đối tượng logger được tạo ra để ghi lại các thông tin liên quan đến hoạt động của AWS X-Ray trong ứng dụng. @Configuration public class XRayConfig { private static final Logger LOG = LoggerFactory.getLogger(XRayConfig.class); } Tạo Constructor XRayConfig(). Trong constructor này, cấu hình cho AWS X-Ray được thiết lập như sau ruleFile: Đọc file cấu hình xray-sampling-rules.json từ resources. File này chứa các quy tắc lấy mẫu cho AWS X-Ray, quy định cách AWS X-Ray nên thu thập dữ liệu. AWSXRayRecorder Tạo một thể hiện của AWSXRayRecorder với cấu hình mặc định, bao gồm các plugin mặc định và chiến lược lấy mẫu từ file được chỉ định. AWSXRay.setGlobalRecorder(awsxRayRecorder): Thiết lập AWSXRayRecorder vừa tạo làm bộ ghi toàn cục cho AWS X-Ray. Trapping exceptions: Trong trường hợp không tìm thấy file cấu hình, một exception FileNotFoundException sẽ được bắt và thông báo lỗi sẽ được ghi lại bằng logger. public XRayConfig() { try { URL ruleFile = ResourceUtils .getURL(\u0026#34;classpath:xray/xray-sampling-rules.json\u0026#34;); AWSXRayRecorder awsxRayRecorder = AWSXRayRecorderBuilder.standard() .withDefaultPlugins() .withSamplingStrategy(new CentralizedSamplingStrategy(ruleFile)) .build(); AWSXRay.setGlobalRecorder(awsxRayRecorder); } catch (FileNotFoundException e) { LOG.error(\u0026#34;XRay config file not found\u0026#34;); } } Tạo Phương thực Bean TracingFilter. Phương thức này định nghĩa một bean kiểu Filter sử dụng AWSXRayServletFilter AWSXRayServletFilter: Là một filter cho servlet, được sử dụng để theo dõi các yêu cầu HTTP đến và đi từ ứng dụng. \u0026ldquo;productsservice\u0026rdquo; là tên dịch vụ được sử dụng trong báo cáo và phân tích của AWS X-Ray. @Bean public Filter TracingFilter() { return new AWSXRayServletFilter(\u0026#34;productsservice\u0026#34;); } Cuối cùng, tạo một xray-sampling-rules.json đã khai báo trước đó. Vào thự mục resource tạo một thư mục mới tên xray và tạo một file json tên là xray-sampling-rules.json Cấu hình file xray-sampling-rules.json như sau { \u0026#34;version\u0026#34;: 2, \u0026#34;default\u0026#34;: { \u0026#34;fixed_target\u0026#34;: 0, \u0026#34;rate\u0026#34;: 1 }, \u0026#34;rules\u0026#34;: [ { \u0026#34;fixed_target\u0026#34;: 0, \u0026#34;rate\u0026#34;: 0, \u0026#34;url_path\u0026#34;: \u0026#34;/actuator/health\u0026#34;, \u0026#34;http_method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Load balancer health check\u0026#34; } ] } "
},
{
	"uri": "//localhost:1313/vi/",
	"title": "Deploy Spring Boot applications onto AWS ECS Fargate using AWS CDK.",
	"tags": [],
	"description": "",
	"content": "Sử dụng AWS CDK để triển khai dịch vụ Spring Boot trên AWS ECS Fargate Tổng quan Trong wokshop này, chúng ta sẽ tạo ra một microservices bằng Java 21, sử dụng framework Spring Boot V3 và các container Docker, xây dựng một ứng dụng backend để tương tác với các tài nguyên của Amazon Web Services (AWS). Các tài nguyên này sẽ được tạo trong AWS bằng cách sử dụng AWS Cloud Development Kit (CDK) V2, một cách hiện đại để mô hình hóa và cấu hình cơ sở hạ tầng trong AWS. AWS CDK là một trong những công cụ tốt nhất cho việc quản lý cơ sở hạ tầng dưới dạng mã, hay còn gọi là IaC (Infrastructure as Code), trên AWS.\nNội dung Giới thiệu Các bước chuẩn bị Tạo kho lưu trữ hình ảnh ECR Tạo VPC và NAT Gateway Tạo ECS Tạo dịch vụ ECS Tạo API Gateway Tạo bảng DynamoDB Cài đặt dịch vụ ECS AWS Dọn dẹp tài nguyên "
},
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Workshop này sẽ bao gồm các tài nguyên và công cụ AWS sau đây: AWS ECS: Dịch vụ Elastic Container Service là dịch vụ điều phối container của AWS. Với dịch vụ này, bạn có thể quản lý việc thực thi các container dịch vụ nhỏ dựa trên Docker một cách mạnh mẽ và có khả năng mở rộng. Với AWS Fargate, dịch vụ tính toán không máy chủ dành cho các container từ Amazon Web Services, bạn không cần tạo các máy EC2, giảm chi phí vận hành của các ứng dụng dựa trên container.\nAWS ECR: Với Elastic Container Registry (ECR) từ AWS, bạn có thể tạo các kho lưu trữ riêng để lưu trữ các hình ảnh Docker của các dịch vụ nhỏ.\nAWS VPC: Với Virtual Private Cloud (VPC) từ AWS, bạn có thể bảo vệ cơ sở hạ tầng bằng các mạng con riêng và các chính sách bảo mật mạng cho các quy tắc lưu lượng đi vào và đi ra.\nAWS ALB: Application Load Balancer từ AWS cho phép cân bằng lưu lượng HTTP đến giữa tất cả các phiên bản ứng dụng có sẵn, và với các nhóm mục tiêu tích hợp, mỗi phiên bản có thể được giám sát để chỉ nhận lưu lượng nếu nó đang hoạt động bình thường.\nAPI Gateway REST: Với AWS API Gateway, bạn có thể bảo vệ API REST của ứng dụng, cũng như thực hiện kiểm tra hợp lệ của các tham số query string và nội dung yêu cầu.\nCloudWatch Logs: Trách nhiệm của nó là tập trung các nhật ký ứng dụng và các chỉ số của chúng. Các ứng dụng sẽ được tạo ra trong khóa học này sẽ tạo ra các nhật ký vào CloudWatch Logs theo định dạng JSON, sử dụng thư viện log4j2. Điều này cho phép chúng ta chèn các tham số vào các nhật ký, để được sử dụng trong các truy vấn trong bảng điều khiển AWS CloudWatch Logs Insights.\nCloudWatch Alarms: Với các cảnh báo từ CloudWatch, bạn có thể theo dõi các sự kiện bất thường từ các ứng dụng và tài nguyên AWS.\nCloudWatch Logs: Trách nhiệm của nó là tập trung các nhật ký ứng dụng và các chỉ số của chúng. Các ứng dụng sẽ được tạo ra trong khóa học này sẽ tạo ra các nhật ký vào CloudWatch Logs theo định dạng JSON, sử dụng thư viện log4j2. Điều này cho phép chúng ta chèn các tham số vào các nhật ký, để được sử dụng trong các truy vấn trong bảng điều khiển AWS CloudWatch Logs Insights.\nDynamoDB: DynamoDB là một dịch vụ quản lý cơ sở dữ liệu NoSQL mạnh mẽ và phi quan hệ. Khóa học này giới thiệu việc sử dụng DynamoDB enhanced client từ AWS SDK V2 cho Java, đây là một thư viện cấp cao cho phép ánh xạ các lớp phía máy khách với các bảng DynamoDB.\nSQS: SQS là một dịch vụ hàng đợi cho phép giao tiếp bất đồng bộ giữa các ứng dụng, nhằm trao đổi các thông điệp và sự kiện.\n"
},
{
	"uri": "//localhost:1313/vi/7-createapigateway/7.1-createnew/",
	"title": "Tạo API Gateway resource",
	"tags": [],
	"description": "",
	"content": "Tạo API Gateway resource Mở CDK project tạo stack mới với tên là ApiStack và cho ApiStack kế thừa lớp Stack của thư viện amazon.awscdk public class ApiStack extends Stack { } Để tạo ApiStack chúng ta cần VPC, Cluster, NetworkLoadBalancer mà chúng ta đã tạo trước đó. Nên chúng ta cần tạo 1 record class tên là ProductsServiceProps để truyền vào ApiStack. Thêm đoạn code bên ngoài class ApiStack record ApiStackProps( NetworkLoadBalancer networkLoadBalancer, VpcLink vpcLink ){} Tạo ApiStack contructor public ApiStack(final Construct scope, final String id, final StackProps props, ApiStackProps apiStackProps) { super(scope, id, props); } Khởi tạo Một đối tượng RestApi, được đặt tên là ECommerceAPI. Đây là một API Gateway, nơi các API endpoint được khai báo và cấu hình. RestApi restApi = new RestApi(this, \u0026#34;RestApi\u0026#34;, RestApiProps.builder() .restApiName(\u0026#34;ECommerceAPI\u0026#34;) .build() ); "
},
{
	"uri": "//localhost:1313/vi/3-createecr/3.1-createfirststack/",
	"title": "Tạo cloudformation stack đầu tiên",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị cho CDK project Xoá file Fcj2024CdkStack đã được tạo sẵn trước đó Xoá những phần comment không cần thiết Tạo 1 stack mới bằng việc tạo 1 file java mới và đặt tên là EcrStack.java Bằng cách sử dụng CDK, bạn có thể viết mã để tạo các stack và tài nguyên của CloudFormation. Mã của bạn sẽ được biên dịch thành các template CloudFormation tương ứng, sau đó có thể được triển khai bởi CloudFormation như bình thường\nSau khi hoàn thành thành để class EcrStack kế thừa từ lớp Stack của thư viện Amzon CDK Tạo stack contructor Tạo AWS resource thông qua repository Đầu tiên tạo thuộc tính productsServiceRepository bằng dòng lệnh bên dưới\nprivate final Repository productsServiceRepository; Tiếp theo Khởi đạo thuộc tính productsServiceRepository trong contructor\nthis.productsServiceRepository = new Repository(); Để khởi tạo Repository ta thêm các parameter sau this, this đề cập đến đối tượng lớp hiện tại (thường là một CDK stack). \u0026ldquo;ProductsService\u0026rdquo;: Đây là tên duy nhất (ID) của tài nguyên được tạo. Tên này là duy nhất trong phạm vi của một stack CDK. Sau đó tạo ECR Repository properties bằng RepositoryProps.builder().build() builder() là một phương thức tĩnh của lớp RepositoryProps để khởi tạo một đối tượng Builder. Đây là một bước chuẩn bị để thiết lập các thuộc tính cho RepositoryProps. Phương thức build() trên đối tượng Builder được gọi để kết thúc quá trình xây dựng và trả về một đối tượng RepositoryProps hoàn chỉnh với các thuộc tính đã thiết lập. Tạo ECR repository name bằng cách thêm đoạn code .repositoryName(\u0026quot;productsservice\u0026quot;) trước build() Them .removalPolicy(RemovalPolicy.DESTROY) để đảm bảo rằng khi khi xoá cloudformation stack resource của chúng ta cũng sẽ được xoá theo Tiếp theo cho phép override các image tren CER repository bằng việc cho phép IMMUTABLE thông qua đoạn code imageTagMutability(TagMutability.IMMUTABLE) Cho phép tự động xoá image khi xoá ECR bằng cách thêm code autoDeleteImages(true) Tạo phương thức Getter public Repository getProductsServiceRepository() { return productsServiceRepository; } "
},
{
	"uri": "//localhost:1313/vi/8-createdynamodb/8.1-createdynamo/",
	"title": "Tạo DynamoDB với CDK",
	"tags": [],
	"description": "",
	"content": "Tạo DynamoDB với CDK Trước tiên ta mở file ProductsServiceStack.java trong constuctor khởi tạo đối tượng Table với ID là ProductsDdb Table productsDdb = new Table(this, \u0026#34;ProductsDdb\u0026#34;, TableProps.builder() .build()); Xác định khóa phân vùng (partition key) của table. Trong workshop này, ta sẽ sử dụng thuộc tính id làm partition key với kiểu dữ liệu là STRING. .partitionKey(Attribute.builder() .name(\u0026#34;id\u0026#34;) .type(AttributeType.STRING) .build()) Đặt tên cho DynamoDB table là products. .tableName(\u0026#34;products\u0026#34;) Tiếp theo ta cấu hình xoá table khi tài nguyên CDK stack của bạn bị xóa .removalPolicy(RemovalPolicy.DESTROY) Tiếp theo chúng ta cần xác định chế độ thanh toán (billing mode) của table. Ở đây, chế độ PROVISIONED được sử dụng, nghĩa là bạn cần chỉ định đủ khả năng đọc và ghi (read và write capacity) cho table. .billingMode(BillingMode.PROVISIONED) Cuối cùng,ta đặt capacity units (đơn vị khả năng) cho table. Trong trường hợp này, đặt read capacity và write capacity là 1, nghĩa là table sẽ có đủ tài nguyên để đọc và ghi ở mức rất thấp. .readCapacity(1) .writeCapacity(1) Cấp quyền để product service có thể truy cập vào dynamoDB Tiếp theo, ta hiện việc cấp quyền cho vai trò của task definition trong Fargate để có thể đọc và ghi dữ liệu vào DynamoDB table productsDdb. Điều này đảm bảo rằng các task trong Fargate có thể tương tác với DynamoDB table này một cách an toàn và theo quy định của IAM (Identity and Access Management) trong AWS. productsDdb.grantReadWriteData(fargateTaskDefinition.getTaskRole()); Thêm 2 biến mối trường là table name và region cho task definition envVariables.put(\u0026#34;AWS_PRODUCTSDDB_NAME\u0026#34;, productsDdb.getTableName()); envVariables.put(\u0026#34;AWS_REGION\u0026#34;, this.getRegion()); "
},
{
	"uri": "//localhost:1313/vi/5-createecs/5.1-createecscluster/",
	"title": "Tạo ECS cluster",
	"tags": [],
	"description": "",
	"content": "Tạo ECS Cluster stack Mở CDK project tạo stack mới với tên là ClusterStack.java Để tạo ECS stack chúng ta cần VPC mà chúng ta đã tạo trước đó. Nên chúng ta cần tạo 1 record class để truyền VPC vào ECS Stack. Thêm đoạn code bên ngoài class ClusterStack record ClusterStackProps( Vpc vpc ){} Tạo thuộc tính cluster và phương thức getter private final Cluster cluster; public Cluster getCluster() { return cluster; } Tạo constructor public ClusterStack(final Construct scope, final String id, final StackProps props, ClusterStackProps clusterStackProps) { super(scope, id, props); } Khởi tạo đối tượng VPC bằng đoạn code sau trong contructor this.cluster = new Cluster(this, \u0026#34;Cluster\u0026#34;, ClusterProps.builder() .build()); Thêm tên của cluster là ECommerce .clusterName(\u0026#34;ECommerce\u0026#34;) Thêm VPC vào cluster .vpc(clusterStackProps.vpc()) Cuối cùng là set containerInsight bằng true .containerInsights(true) Tổ chức ECS stack in CDK project Mở file root Fcj2024CdkApp Tạo ECS Stack với id là Vpc bằng đoạn code ClusterStack clusterStack = new ClusterStack(app, \u0026#34;Cluster\u0026#34;, StackProps.builder() .build()); Truyền VPC đã tạo trước đó cho ClusterStackProps của ECS stack new ClusterStackProps(vpcStack.getVpc()) Thêm environmen* và Tags cho ECS Stack .env(environment) .tags(infraTags) Bởi vì ECS cần có VPC nhưng chúng ta không thể biết chắc chắn rằng VPC có được tạo trước CES hay không. Vì vậy hãy thêm một ràng buộc là khi nào việc tạo VPC hoàn thành rồi ECS mới được tạo bằng cách clusterStack.addDependency(vpcStack); Deloy Ecs cluster bằng AWS CDK Để deloy ecs cluster, mở terminal và nhập Ta có thể deploy tất cả các stack bằng cdk deploy --all Ngoài ra chúng ta có thể bỏ qua bước confirm bằng cách cdk deploy --all --require-approval never Deloy Ecs cluster bằng AWS CDK Kiểm tra cluster vừa tạo Truy cập vào AWS console, Nhập ECS, chọn Elastic Container Service\nTrong giao diện ECS, ta có thể thấy 1 cluster tên ECommerce đã được tạo "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.1-createinfrastructureproject/",
	"title": "Tạo infrastructure project with AWS CDK",
	"tags": [],
	"description": "",
	"content": "infrastructure project sử dụng AWS CDK Mở termial tại thư mục bạn muốn tạo project Nhập lệnh sau cdk init app --language java Bài workshop này sẻ sử dụng java. Ngoài ra bạn có thể tạo bằng python hoặc typescipt\nMở IntelliJ IDEA và mở project chúng ta vừa tạo "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.1-createnewstack/",
	"title": "Tạo Stack mới cho product service",
	"tags": [],
	"description": "",
	"content": "Tạo Stack mới cho product service Mở CDK project tạo stack mới với tên là ProductsServiceStack và cho ProductsServiceStack kế thừa lớp Stack của thư viện amazon.awscdk Để tạo ProductsServiceStack chúng ta cần VPC, Cluster, NetworkLoadBalancer, ApplicationLoadBalancer và Repository mà chúng ta đã tạo trước đó. Nên chúng ta cần tạo 1 record class tên là ProductsServiceProps để truyền vào ProductsServiceStack. Thêm đoạn code bên ngoài class ClusterStack record ProductsServiceProps( Vpc vpc, Cluster cluster, NetworkLoadBalancer networkLoadBalancer, ApplicationLoadBalancer applicationLoadBalancer, Repository repository ){} Tạo Contructor public ProductsServiceStack(final Construct scope, final String id, final StackProps props, ProductsServiceProps productsServiceProps) { super(scope, id, props); } "
},
{
	"uri": "//localhost:1313/vi/4-createvpc/4.1-createvpc/",
	"title": "Tạo VPC và Nat gateway",
	"tags": [],
	"description": "",
	"content": "Tạo VPC và Nat gateway Mở CDK project tạo stack mới với tên là VpcStack.java Kế thừa Stack của thư viện awscdk vào tạo constructor Tạo thuộc tính VPC và tạo phương thức getter Thêm thuộc tính bằng đoạn code sau private final Vpc vpc; Tiếp đó chúng ta tạo hàm getter để có thể sử dụng VPC này cho các resource khác public Vpc getVpc() { return vpc; } Khởi tạo đối tượng VPC bằng đoạn code sau trong contructor this.vpc = new Vpc(this, \u0026#34;Vpc\u0026#34;, VpcProps.builder() .build()); Tiếp theo đặt tên cho PVC là ECommerceVPC và số lương Availability Zones là 2 thông qua đoạn code\n.vpcName(\u0026#34;ECommerceVPC\u0026#34;) .maxAzs(2) Nếu bạn muốn VPC của bạn là Public và không sử dụng Nat gateway bạn có thể thêm đoạn code .natGateways(0) Bạn có thể không sử dụng Nate gateway khi làm lab để tiết kiệm chi phí nhưng đừng làm trong môi trường production\n"
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Các bước chuẩn bị Java Development Kit (JDK) Đầu tiên chúng ta cần cài đặt Java Development Kit (JDK). Trong workshop nảy chúng ta sẽ dùng JDK 21 LTS. Bạn có thể tải tại đường dẫn này Tiếp theo chúng ta cần cài đặt maven. Bạn có thể cài đặt theo hướng dẫn NodeJS để cài dặt AWS CDK CLI chúng ta cần phải cài đặt NodeJS. Truy cập đường dẫn. Tải về phiên bản LTS mới nhất\nKiểm tra NodeJS đã được cài đặt đúng chưa, thực hiện lệnh sau trong terminal\nnode -v Lệnh này sẽ show phiên bản NodeJS đã được cài đặt v18.15.0 Kiểm tra phiên bản NPM đã được cài đặt, thực hiện lệnh sau trong terminal npm -v Command sẽ show phiên bản NPM đã được cài đặt 9.6.2 AWS CLI Truy cập liên kết này và tải về phiên bản mới nhất Sau khi cài đặt hoàn thành mở termial và kiểm tra phiên bản AWS CLI vừa cài đặt, thông qua lênh sau aws --v AWS CDK AWS Cloud Development Kit, or AWS CDK sẽ được sử dụng để xây dựng mã chịu trách nhiệm tạo cơ sở hạ tầng ứng dụng sử dụng dịch vụ AWS. Sau khi cài đặt các gói được đề cập ở trên, hãy thực hiện lệnh sau trong cửa sổ terminal trên hệ điều hành của bạn để cài đặt AWS CDK: npm install -g aws-cdk Kiểm tra CDK đã được cài đặt đúng chưa, thực hiện lệnh sau trong terminal cdk --version Postman Postman là một ứng dụng miễn phí rất hữu ích. Bằng cách sử dụng nó, bạn có thể gửi các yêu cầu tới các ứng dụng được phát triển trong workshop này, bất kể chúng có đang chạy trên máy tính của bạn hay đã được triển khai trên tài khoản AWS của bạn. Tải Postman dựa vào chỉ dẫn sau IntelliJ IDEA Community Edition IDE mà sẽ được sử dụng là IntelliJ IDEA Community Edition, từ công ty JetBrains. Đây là một trong những IDE hiện đại nhất để phát triển trong Java và các ngôn ngữ lập trình khác. Tải IntelliJ IDEA Community Edition thông qua đường dẫn này Docker Desktop Docker Desktop sẽ được sử dụng để tạo image Docker của tất cả các ứng dụng sẽ được tạo bằng nó workshop này trước khi tải image lên AWS Tải docker thông qua đường dẫn "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.2-createectask/",
	"title": "Tạo ECS task definition",
	"tags": [],
	"description": "",
	"content": "Tạo CES task definition Trong ProductsServiceStack contructor khởi tạo đối tượng FargateTaskDefinition FargateTaskDefinition fargateTaskDefinition = new FargateTaskDefinition(this, \u0026#34;TaskDefinition\u0026#34;, FargateTaskDefinitionProps.builder() .build()); Tạo tên group của tất cả các task definition bạn đã tạo .family(\u0026#34;products-service\u0026#34;) Tiếp theo chúng ta định nghĩa số lượng cpu là 512 và memory là 1024 .cpu(512) .memoryLimitMiB(1024) "
},
{
	"uri": "//localhost:1313/vi/5-createecs/5.2-createnlb/",
	"title": "Tạo Network Load Balancer",
	"tags": [],
	"description": "",
	"content": "Tạo Network Load Balancer stack Trong CDK project tạo stack mới với tên là NlbStack.java và sau đó cho class NlbStack kế thừa lớp Stack cửa thư viện amazon.awscdk Để tạo NLB stack chúng ta cần VPC mà chúng ta đã tạo trước đó. Nên chúng ta cần tạo 1 record class tên là NlbStackProps để truyền VPC vào NLB Stack. Thêm đoạn code bên ngoài class ClusterStack record NlbStackProps( Vpc vpc ){} Trong NLB Stack chúng ta sẽ tạo Vpc Link, Network Load Balancer, Application Load Balancer nên trước tiên chúng ta cần tạo 3 thuộc tính ứng với chúng. private final VpcLink vpcLink; private final NetworkLoadBalancer networkLoadBalancer; private final ApplicationLoadBalancer applicationLoadBalancer; Tiếp theo, chúng ta tạo các getter cho 3 thuộc tính trên public VpcLink getVpcLink() { return vpcLink; } public NetworkLoadBalancer getNetworkLoadBalancer() { return networkLoadBalancer; } public ApplicationLoadBalancer getApplicationLoadBalancer() { return applicationLoadBalancer; } Tạo contructor cho class NlbStack public NlbStack(final Construct scope, final String id, final StackProps props, NlbStackProps nlbStackProps) { super(scope, id, props); } Tạo network load balancer Trước tiên chúng ta sẽ tạo network load balancer (NLB). Để tạo NLB chúng ta cần khởi tạo đối tượng networkLoadBalancer trong contructor this.networkLoadBalancer = new NetworkLoadBalancer(this, \u0026#34;Nlb\u0026#34;, NetworkLoadBalancerProps.builder() .build()); Tiếp theo đặt tên cho NLB là ECommerceNlb bằng cách .loadBalancerName(\u0026#34;ECommerceAlb\u0026#34;) Như trong thiết kế trên diagram. Chúng ta sẽ khổng để NLB và ALB ngoài VPC nên chúng ta sẽ làm như sau .internetFacing(false) .vpc(nlbStackProps.vpc()) "
},
{
	"uri": "//localhost:1313/vi/7-createapigateway/7.2-createfirstmethod/",
	"title": "Tạo product resource và method đầu tiên",
	"tags": [],
	"description": "",
	"content": "Tạo product resource và method đầu tiên Tạo phương thức createProductsResource với 2 tham số là RestApi và ApiStackProps và khởi tạo trong contructor private void createProductsResource(RestApi restApi, ApiStackProps apiStackProps) { } Tạo một tài nguyên (resource) mới trong API Gateway với đường dẫn là /products. Sử dụng restApi.getRoot().addResource(\u0026ldquo;products\u0026rdquo;) sẽ tạo ra một tài nguyên con mới (sub-resource) có đường dẫn là /products từ root của API (restApi). //products Resource productsResource = restApi.getRoot().addResource(\u0026#34;products\u0026#34;); Thêm phương thức GET cho productsResource bằng phương thức addMethod productsResource.addMethod(\u0026#34;GET\u0026#34;); Tiếp theo chúng ta sẽ định nghĩa một Integration để xử lý yêu cầu GET tới endpoint /products. productsResource.addMethod(\u0026#34;GET\u0026#34;, new Integration( IntegrationProps.builder() .build())); Sau đó, chọn loại Integration là HTTP_PROXY, nghĩa là sử dụng proxy HTTP để chuyển tiếp yêu cầu và chọn Loại phương thức của Integration là GET. .type(IntegrationType.HTTP_PROXY) .integrationHttpMethod(\u0026#34;GET\u0026#34;) Đặt URI của backend mà API Gateway sẽ chuyển tiếp yêu cầu tới. Trong đó, DNS name của NetworkLoadBalancer được sử dụng để tạo URL và cổng 8081 cùng với đường dẫn API /api/products được gọi. .uri(\u0026#34;http://\u0026#34; + apiStackProps.networkLoadBalancer().getLoadBalancerDnsName() +\u0026#34;:8080/api/products\u0026#34;) Tiếp theo dùng options được sử dụng để cấu hình thêm các tùy chọn IntegrationOptions .options(IntegrationOptions.builder() .build()) Chỉ định VpcLink để xác định kết nối VPC nào sẽ được sử dụng cho phương thức Integration và xác định loại kết nối là VPC_LINK, nghĩa là kết nối qua VPC của AWS. .vpcLink(apiStackProps.vpcLink()) .connectionType(ConnectionType.VPC_LINK) "
},
{
	"uri": "//localhost:1313/vi/8-createdynamodb/8.2-post/",
	"title": "Tạo REST operation để tạo product mới",
	"tags": [],
	"description": "",
	"content": "Tạo REST operation để tạo product mới Mở file ApiStack.java trong createProductsResource dùng phương thức addMethod để tạo method PUT cho productsResource resource productsResource.addMethod(\u0026#34;POST\u0026#34;); Tiếp theo chúng ta sẽ định nghĩa một Integration để xử lý yêu cầu POST tới endpoint /products. Phần này tương tự với GET chúng ta chỉ cần thay integrationHttpMethod(\u0026ldquo;POST\u0026rdquo;) productsResource.addMethod(\u0026#34;POST\u0026#34;, new Integration( IntegrationProps.builder() .type(IntegrationType.HTTP_PROXY) .integrationHttpMethod(\u0026#34;POST\u0026#34;) .uri(\u0026#34;http://\u0026#34; + apiStackProps.networkLoadBalancer().getLoadBalancerDnsName() + \u0026#34;:8081/api/products\u0026#34;) .options(IntegrationOptions.builder() .vpcLink(apiStackProps.vpcLink()) .connectionType(ConnectionType.VPC_LINK) .build()) .build())); "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.2-createspingbootproject/",
	"title": "Tạo Spring Boot project",
	"tags": [],
	"description": "",
	"content": "Tạo Spring Boot project Truy câp vào đường dẫn start.spring.io Chọn ngôn ngữ lập trình và phiên bản framework Với Project chọn Gradle - Groovy Với Language chọn Java Với phiên bản Spring Boot chọn 3.2.4 Cấu hình Project Metadata Với Group nhập com.firstcloudjourney Với Artifact nhập productsservice Các phần còn lại sẽ được tự động điền Chọn phiên bản java là 21 Thêm Dependencies Nhấn vào ADD DEPENDENCIES một pop up hiện lên Thêm các package lần lượt là Spring Web và Spring Boot Actuator Tạo project springboot Nhấn GENERATE để tài về project vừa tạo "
},
{
	"uri": "//localhost:1313/vi/9-intrumentingecs/9.2-createxrayinspector/",
	"title": "Tạo X-Ray inspector",
	"tags": [],
	"description": "",
	"content": "Tạo X-Ray inspector Trước tiên để đo lường các phương thức ta cần thêm Annotation @XRayEnabled ở file ProductRepository và ProductsController Trong thư mục config tạo một file mới có tên là XRayInspector Thêm 2 annotation vào class XRayInspector với @Aspect: Đây là một annotation của Spring AOP. Nó chỉ ra rằng lớp này sẽ chứa logic cross-cutting, nghĩa là các hành vi (behavior) mà có thể ảnh hưởng hoặc được áp dụng trên nhiều lớp hoặc phương thức khác nhau. Trong trường hợp này, đó là việc thêm các thông tin giám sát từ AWS X-Ray @Component: Annotation này của Spring Framework đánh dấu lớp như một \u0026ldquo;component\u0026rdquo;, cho phép Spring tự động phát hiện và quản lý nó như một bean trong ApplicationContext. cho Class XRayInspector kế thừa từ BaseAbstractXRayInterceptor, một lớp trừu tượng được sử dụng để tạo ra các interceptor cho AWS X-Ray, nơi các phương thức có thể được ghi đè để tùy chỉnh hành vi của các subsegment trong AWS X-Ray. @Aspect @Component public class XRayInspector extends BaseAbstractXRayInterceptor { @Override protected void xrayEnabledClasses() { } } Tạo phương thức Method generateMetadata(). Phương thức này được ghi đè từ lớp cha (BaseAbstractXRayInterceptor). Nó nhằm mục đích tạo ra metadata cho một subsegment của AWS X-Ray dựa trên điểm nối (join point) đang được tiến hành. ProceedingJoinPoint là một khái niệm trong AOP đại diện cho một điểm thực thi mà tại đó có thể xảy ra một quá trình chèn (interception) và Subsegment là một phần của trace trong AWS X-Ray, cho phép thu thập thêm thông tin. Trong trường hợp này, phương thức chỉ đơn giản gọi phương thức của lớp cha bằng super.generateMetadata(). @Override protected Map\u0026lt;String, Map\u0026lt;String, Object\u0026gt;\u0026gt; generateMetadata( ProceedingJoinPoint proceedingJoinPoint, Subsegment subsegment ) { return super.generateMetadata(proceedingJoinPoint, subsegment); } Phương thức xrayEnabledClasses() là một phương thức được đánh dấu với annotation @Pointcut. Annotation này chỉ định một biểu thức pointcut trong Spring AOP, mô tả tại đâu một advice (lời khuyên) nên được áp dụng. Trong trường hợp này, biểu thức pointcut @within(com.amazonaws.xray.spring.aop.XRayEnabled) chỉ ra rằng advice sẽ được áp dụng cho bất kỳ lớp nào được đánh dấu với annotation @XRayEnabled do com.amazonaws.xray.spring.aop cung cấp. Phương thức không có nội dung bên trong, vì nó chỉ dùng để xác định vị trí áp dụng advice @Override @Pointcut(\u0026#34;@within(com.amazonaws.xray.spring.aop.XRayEnabled)\u0026#34;) protected void xrayEnabledClasses() {} Thêm X-Ray interceptor vào DynamoDB Client Mở file DynamoDBConfig ta thêm interceptor vào dynamoDbAsyncClient như sau .overrideConfiguration(ClientOverrideConfiguration.builder() .addExecutionInterceptor(new TracingInterceptor()) .build()) Cuối cùng thêm @EnableAspectJAutoProxy vào ProductsserviceApplication "
},
{
	"uri": "//localhost:1313/vi/3-createecr/3.2-organizestack/",
	"title": "Tổ chức CDK stack in CDK project",
	"tags": [],
	"description": "",
	"content": "Tổ chức CDK stack in CDK project Mở file root Fcj2024CdkApp Tạo ECR Stack bằng đoạn code EcrStack ecrStack = new EcrStack(app, \u0026#34;Ecr\u0026#34;, StackProps.builder() .build()); Tạo Evirontment bằng đoạn code Environment environment = Environment.builder() .account(\u0026#34;your_account_id\u0026#34;) .region(\u0026#34;ap-southeast-1\u0026#34;) .build(); Với account là Account ID của tài khoản AWS của bạn Với region là region bạn muốn tạo resource ở đây chúng ta sẽ chọn ap-southeast-1 Thêm Evirontment vào ECRStack bằng đoạn code .env(environment) Tạo thuộc tính infraTags cho Tags Map\u0026lt;String, String\u0026gt; infraTags = new HashMap\u0026lt;\u0026gt;(); infraTags.put(\u0026#34;team\u0026#34;, \u0026#34;FirstCloudJourney\u0026#34;); infraTags.put(\u0026#34;cost\u0026#34;, \u0026#34;ECommerceInfra\u0026#34;); Thêm Tags cho ECRStack .tags(infraTags) Kiểm tra các stack mà CDK sẽ tạo cho cloudformation bằng lệnh cdk list ở đây CDK cho chúng ta thấy có 1 stack duy nhất đó là Ecr Để chuẩn bị môi trường triển khai cho các ứng dụng CDK trên AWS, bao gồm việc tạo các tài nguyên cần thiết để triển khai và quản lý các ứng dụng CDK một cách hiệu quả trên nền tảng AWS chúng ta cần chạy lệnh cdk bootstrap --profile default Để xem những gì chúng ta vừa toạ từ lệnh cdk bootstrap \u0026ndash;profile default truy cập vào AWS console nhập Cloudformation Trong giao diện Cloudformation, ta có thể thấy môt CDKToolkit vừ được tạo Chọn CDKToolkit và sau đó chọn resource tab để xem những resource đã được tạo "
},
{
	"uri": "//localhost:1313/vi/4-createvpc/4.2-orgaizestack/",
	"title": "Tổ chức và deploy VPC stack sử dụng AWS CDK",
	"tags": [],
	"description": "",
	"content": "Tổ chức VPC stack in CDK project Mở file root Fcj2024CdkApp Tạo VPC Stack với id là Vpc bằng đoạn code VpcStack vpcStack = new VpcStack(app, \u0026#34;Vpc\u0026#34;, StackProps.builder() .build()); Thêm environment và Tags Deploy VPC stack Bật termial và nhập lệnh ```cdk list`` để xem danh sách các task đang có. Ở đây ta có thể thấy Ecr và Vpc Tiếp theo nhập cdk deploy \u0026ndash;all để deploy tất cả stack. Khi được hỏi về những thay đổi policy. Nhập y Kiểm tra những thay đổi khi deploy. Ta có thể thấy rằng CDK nhận ra CER không đổi và chúng ta đang tạo một stack mới là VPC Kiểm tra resouce đã tạo trên aws console Truy cập vào aws console vào giao diện VPC và chọn Your VPCs. Ta có thể thấy ECommerceVPC đã được tạo Tương tự như vậy với Subnet,NAT gateway, security group\u0026hellip; "
},
{
	"uri": "//localhost:1313/vi/3-createecr/3.3-implementstack/",
	"title": " Triển khai Stack lên AWS ECR",
	"tags": [],
	"description": "",
	"content": "Triển khai Stack lên AWS ECR Để triển khia stak lên AWS ECR chúng ta nhập ```cdk deploy Ecr \u0026ndash;profile default`` Trong quá trình tạo resource, có vài câu hỏi về security policy chúng ta cần thay đổi. Nhập y Tạo ECR thành công Truy cập vào AWS console nhập ECR và chọn Elastic Container Registry Ta có thể thấy repository productsservice đã được tạo "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.3-setupintellijidea/",
	"title": "Chuẩn bị IntelliJ IDEA",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị IntelliJ IDEA Dùng IntelliJ IDEA mở project spring boot vừa tạo Cài đặt project lick phải vào project chọn Open Module Settings Chọn Project Setting, hãy đảm bảo rằng project của bạn có SDK là 21 và language level là 21 Chọn Platform setting, hãy đảm bảo rằng platform SDK của bạn là 21 Chạy spring boot project Mở file application.properties thêm vào server.port=8081 để cấu hình project chạy trên port 8081 Nhấn vào biểu tượng Run để chạy project, bạn có thể thấy project đang chạy trên port 8081 Kiểm thử project trên postman Tạo request HTTP GET với đường dẫn http://localhost:8080/actuator/health để kiểm tra Reponse trả về \u0026ldquo;status\u0026rdquo;: \u0026ldquo;UP\u0026rdquo; chứng tỏ project hoạt đông bình thường Thêm thư viên Log4j2 Mở file build.grade Trong phần dependencies thêm thư viện Log4j2 bằng cách thêm đoạn mã sau implementation 'org.springframework.boot:spring-boot-starter-log4j2' Thêm configurations configurations { configureEach { exclude group: \u0026#39;org.springframework.boot\u0026#39;, module: \u0026#39;spring-boot-starter-logging\u0026#39; exclude group: \u0026#39;commons-logging\u0026#39;, module: \u0026#39;commons-logging\u0026#39; } } Tạo Controller Trong thư mục com.firstcloudjourney.productsservice tạo folder products Trong thư mục products tạo thư mục controllers và tạo file ProductsController.java từ thư mục controllers\nCopy đoạn code sau vào file ProductsController.java @RestController @RequestMapping(\u0026#34;/api/products\u0026#34;) public class ProductsController { private static final Logger LOG = LogManager.getLogger(ProductsController.class); @GetMapping public String getAllProducts() { LOG.info(\u0026#34;Get all products\u0026#34;); return \u0026#34;All products\u0026#34;; } } Chạy project và test trên postman bằng cách tạo request HTTP GET với đường dẫn http://localhost:8081/api/products Kiểm tra log trả về trên termnial khi gọi HTTP GET "
},
{
	"uri": "//localhost:1313/vi/3-createecr/",
	"title": "Tạo AWS ECR image repository bằng AWS CDK",
	"tags": [],
	"description": "",
	"content": "Trong phần này chúng ta sẽ tìm hiểu về cách tạo stack để triển khai ECR trên AWS\n"
},
{
	"uri": "//localhost:1313/vi/8-createdynamodb/8.3-put/",
	"title": "Tạo REST operation để UPDATE product bằng ID",
	"tags": [],
	"description": "",
	"content": "Tạo REST operation để cập nhật product bằng ID Tạo một đối tượng Resource mới bằng cách gọi phương thức addResource(\u0026quot;{id}\u0026quot;) trên đối tượng productsResource. Đây là một phần của cấu hình định tuyến của API Gateway, cho phép xử lý các request đến /{id}. Resource productIdResource = productsResource.addResource(\u0026#34;{id}\u0026#34;); Thêm một Method mới vào productIdResource bằng cách sử dụng phương thức addMethod(\u0026ldquo;PUT\u0026rdquo;) productIdResource.addMethod(\u0026#34;PUT\u0026#34;) Tiếp theo ta cần cấu hình Integration cho Method. Ta có thể sử dụng lại intergation ở phần trước và thay đổi integrationHttpMethod với phương thức HTTP là PUT productIdResource.addMethod(\u0026#34;PUT\u0026#34;, new Integration( IntegrationProps.builder() .type(IntegrationType.HTTP_PROXY) .integrationHttpMethod(\u0026#34;PUT\u0026#34;) .uri(\u0026#34;http://\u0026#34; + apiStackProps.networkLoadBalancer().getLoadBalancerDnsName() + \u0026#34;:8080/api/products/{id}\u0026#34;) .options(IntegrationOptions.builder() .vpcLink(apiStackProps.vpcLink()) .connectionType(ConnectionType.VPC_LINK) .build()) .build())); Sau đó chúng ta cần thêm requestParameter sau connection type .requestParameters() Bạn có thể thấy requestParameters yêu cầu kiểu dữ liệu Map\u0026lt;String,Sring\u0026gt; hãy định nghĩa nó. Trước tiên tạo Map tên là productIdIntegrationParameters Trong đó integration.request.path.id như một key trong productIdIntegrationParameters và gán giá trị của nó thành method.request.path.id, bạn đang cấu hình API Gateway để lấy giá trị id từ path của request gốc mà client gửi đến, và truyền nó tới backend dưới cùng tên tham số trong request path của backend. Map\u0026lt;String, String\u0026gt; productIdIntegrationParameters = new HashMap\u0026lt;\u0026gt;(); productIdIntegrationParameters.put(\u0026#34;integration.request.path.id\u0026#34;, \u0026#34;method.request.path.id\u0026#34;); Sử dụng MethodOptions.builder().requestParameters(productIdMethodParameters).build() để thiết lập các tham số của method, trong trường hợp này là productIdMethodParameters, nơi chỉ định rằng path.id là bắt buộc khi gửi request. Trước tiên tạo Map tên là productIdMethodParameters để đảm bảo rằng ID là bắt buộc khi gửi request Map\u0026lt;String, Boolean\u0026gt; productIdMethodParameters = new HashMap\u0026lt;\u0026gt;(); productIdMethodParameters.put(\u0026#34;method.request.path.id\u0026#34;, true); Thêm productIdMethodParameters vào methodOptions MethodOptions.builder() .requestParameters(productIdMethodParameters) .build() "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.3-createsericelogdriver/",
	"title": "Tạo Service Log Driver",
	"tags": [],
	"description": "",
	"content": "Tạo Service Log Driver Trong quá trình phát triển a spring boot application, chúng ta cần log để debug application do đó chúng ta cần sử dụng Log Group của CloudWatch\nĐể tạo log group, trước tiên ta cần khởi tạo đối tượng AwsLogDriver trong contructor\nAwsLogDriver logDriver = new AwsLogDriver(AwsLogDriverProps.builder() .build()); Khởi tạo đối tượng LogGroup trong AwsLogDriver .logGroup(new LogGroup(this, \u0026#34;LogGroup\u0026#34;, LogGroupProps.builder() .build())) Tiếp theo chúng ta cần thêm các thuộc tính cần thiết cho LogGroup Với tên cho groug log là ProductsService .logGroupName(\u0026#34;ProductsService\u0026#34;) Tiếp theo cho ta sẽ cấu hình xoá log group khi delete Stack .removalPolicy(RemovalPolicy.DESTROY) Cuối cùng cho ta sẽ cho AWS biết là sẽ giữ những log này trong bao lâu. Ỡ đâu chúng ta sẽ giữ 1 tháng .retention(RetentionDays.ONE_MONTH) Cuối cùng chúng tao cần tạo prefix cho file của chúng ta .streamPrefix(\u0026#34;ProductsService\u0026#34;) "
},
{
	"uri": "//localhost:1313/vi/5-createecs/5.3-createvpclink/",
	"title": "Tạo VPC Link",
	"tags": [],
	"description": "",
	"content": "Tạo VPC link Để tạo VPC link chúng ta cần khởi tạo đối tượng vpcLink đã khai báo trước đó this.vpcLink = new VpcLink(this, \u0026#34;VpcLink\u0026#34;, VpcLinkProps.builder() .build()); Tiếp theo chúng ta sẽ kết nối PVC Link với Network Load Balancer tạo 1 target đến NLB .targets(Collections.singletonList(this.networkLoadBalancer)) "
},
{
	"uri": "//localhost:1313/vi/9-intrumentingecs/9.3-addxraytotask/",
	"title": "Tạo X-Ray inspector",
	"tags": [],
	"description": "",
	"content": "Thêm một container phụ (sidecar) X-Ray vào ProductsServices task definition Mở project FCJ2024_SDK và chọn file ProductsServiceStack.java Thêm các biến mội trường cho X-Ray như sau envVariables.put(\u0026#34;AWS_XRAY_DAEMON_ADDRESS\u0026#34;, \u0026#34;0.0.0.0:2000\u0026#34;); envVariables.put(\u0026#34;AWS_XRAY_CONTEXT_MISSING\u0026#34;, \u0026#34;IGNORE_ERROR\u0026#34;); envVariables.put(\u0026#34;AWS_XRAY_TRACING_NAME\u0026#34;, \u0026#34;productsservice\u0026#34;); Trong phần fargateTaskDefinition.addContainer thêm CPU là 348 và memory là 896 .cpu(384) .memoryLimitMiB(896) Tiếp theo, thêm một container phụ (sidecar) X-Ray vào ProductsServices task definition như sau fargateTaskDefinition.addContainer(\u0026#34;xray\u0026#34;, ContainerDefinitionOptions.builder() .image(ContainerImage.fromRegistry(\u0026#34;public.ecr.aws/xray/aws-xray-daemon:latest\u0026#34;)) .containerName(\u0026#34;XRayProductsService\u0026#34;) .logging(new AwsLogDriver(AwsLogDriverProps.builder() .logGroup(new LogGroup(this, \u0026#34;XRayLogGroup\u0026#34;, LogGroupProps.builder() .logGroupName(\u0026#34;XRayProductsService\u0026#34;) .removalPolicy(RemovalPolicy.DESTROY) .retention(RetentionDays.ONE_MONTH) .build())) .streamPrefix(\u0026#34;XRayProductsService\u0026#34;) .build())) .portMappings(Collections.singletonList(PortMapping.builder() .containerPort(2000) .protocol(Protocol.UDP) .build())) .cpu(128) .memoryLimitMiB(128) .build()); Cấp quyền để cho phép các containers trong task có khả năng gửi dữ liệu đến AWS X-Ray mà không cần quyền đọc hoặc quản lý các tài nguyên X-Ray. Điều này giúp việc theo dõi và phân tích hiệu suất của ứng dụng được thực hiện một cách an toàn và hiệu quả. fargateTaskDefinition.getTaskRole().addManagedPolicy(ManagedPolicy.fromAwsManagedPolicyName(\u0026#34;AWSXrayWriteOnlyAccess\u0026#34;)); "
},
{
	"uri": "//localhost:1313/vi/7-createapigateway/7.3-organizestack/",
	"title": "Tổ chức Stack",
	"tags": [],
	"description": "",
	"content": "Tổ chức Stack Mở file root Fcj2024CdkApp Tạo ApiStack với id là Api ApiStack apiStack = new ApiStack(app, \u0026#34;Api\u0026#34;, StackProps.builder() .build(), new ApiStackProps( nlbStack.getNetworkLoadBalancer(), nlbStack.getVpcLink())); Thêm environmen* và Tags cho ApiStack .env(environment) .tags(infraTags) Thêm phụ thuộc để đảm bảo rằng NLB được tao trước API Gateway apiStack.addDependency(nlbStack); Kiểm tra resource Trong giao diện AWS console, nhập API Gateway Trong giao diện API Gateway chọn APIs ta có thể thấy một API tên ECommerceAPI đã được tạo Chọn ECommerceAPI sau đó chọn GET Test API trên postman Trong giao diện ECommerceAPI chọn Stages và copy Invoke URL Mở postman và tạo phương thức GET với đường dẫn Invoke URL/product "
},
{
	"uri": "//localhost:1313/vi/3-createecr/3.4-pushimage/",
	"title": " Push Docker image lên ECR",
	"tags": [],
	"description": "",
	"content": "Push Docker image lên ECR repository Hãy đảm bảo là bạn đã cài AWS toolkit. Nếu chưa vào IntelliJ IDEA setting chọn plugins và tìm AWS toolkit để cài đặt Chọn biểu tưởng AWS toolkit bên phải phần mềm IntelliJ IDEA Chọn profile và region Với profile chọn defautl Region chọn ap-southeast-1 Chọn Exploxer để xem tất cả dịch vụ AWS toolkit hỗ trợ sau đó chọn ECR Ta có thể thấy có 2 repository chúng ta sẽ push docker image lên productsservice repository bằng cách lick phải vào productsservice và chọn push to Repository\u0026hellip; Pop up Push to ECR hiện lên Với local image chọn productsservice:1.0.0 Với ECR Repository chọn productsservice Với Remote Tag nhập 1.0.0 Cuối cùng chọn Push Kiểm tra image trên ECR Trong giao diện AWS console truy cập vào ECR Chọn productsservice Repository ta có thể thấy docker image phiên bản 1.0.0 đã được push lên "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.4-addservicetotask/",
	"title": " Thêm container service vào task definition",
	"tags": [],
	"description": "",
	"content": "Thêm container service vào task definition Để thêm container phương thức addContainer của fargateTaskDefinition đã khởi tạo trước đó fargateTaskDefinition.addContainer() Thêm id là ProductsServiceContainer và tạo ContainerDefinitionOptions fargateTaskDefinition.addContainer(\u0026#34;ProductsServiceContainer\u0026#34;, ContainerDefinitionOptions.builder() .build()); Thêm image từ ECR Repository với phiên bản 1.0.0 chúng ta đã tạo trước đó .image(ContainerImage.fromEcrRepository(productsServiceProps.repository(), \u0026#34;1.0.0\u0026#34;)) Tiếp theo ta cần đặt tên cho Container và là thêm logDriver đã tạo trước đó .containerName(\u0026#34;productsService\u0026#34;) .logging(logDriver) Bời vì ứng dụng của chúng ta sử dũng port 8081, do đó chúng ta cần thêm port cho container service .portMappings(Collections.singletonList(PortMapping.builder() .containerPort(8081) .protocol(Protocol.TCP) .build())) Tiếp theo chúng ta cần tạo environtment. Giá trị của nó là một Map\u0026lt;String, String\u0026gt; Trước tiên chúng ta cần khai báo 1 biến envVariables Map\u0026lt;String, String\u0026gt; envVariables = new HashMap\u0026lt;\u0026gt;(); envVariables.put(\u0026#34;SERVER_PORT\u0026#34;, \u0026#34;8081\u0026#34;); Tiếp theo thêm environment cho service container .environment(envVariables) "
},
{
	"uri": "//localhost:1313/vi/5-createecs/5.4-createalb/",
	"title": "Tạo Application Load Balancer",
	"tags": [],
	"description": "",
	"content": "Tạo Application Load Balancer Trước tiên chúng ta sẽ tạo Application Load Balancer (NLB). Để tạo SLB chúng ta cần khởi tạo đối tượng applicationLoadBalancer trong contructor this.applicationLoadBalancer = new ApplicationLoadBalancer(this, \u0026#34;Alb\u0026#34;, ApplicationLoadBalancerProps.builder() .build()); Tiếp theo đặt tên cho NLB là ECommerceNlb bằng cách .loadBalancerName(\u0026#34;ECommerceAlb\u0026#34;) Như đã để cập trước đó. Chúng ta sẽ khổng để NLB và ALB ngoài VPC nên chúng ta sẽ làm như sau .internetFacing(false) .vpc(nlbStackProps.vpc()) "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.4-createdockerfile/",
	"title": "Tạo Dockerfile và generate docker image",
	"tags": [],
	"description": "",
	"content": "Tạo task Trước tiên bạn cần phải tạo task trên file build.grade bằng cách copy đoạn code sau tasks.register(\u0026#34;unpack\u0026#34;, Copy) { dependsOn bootJar from(zipTree(tasks.bootJar.outputs.files.singleFile)) into(\u0026#34;build/libs\u0026#34;) } Đoạn mã này là một đoạn mã sử dụng Gradle để định nghĩa một task mới có tên là \u0026ldquo;unpack\u0026rdquo;. Hành động của task này là sao chép (copy) các file từ một tệp nén (ZIP) của task \u0026ldquo;bootJar\u0026rdquo; và giải nén chúng vào thư mục \u0026ldquo;build/libs\u0026rdquo;.\nTạo file .dockerignore Tạo file .dockerignore để chỉ định những file và thư mục mà Docker sẽ bỏ qua (ignore) khi bạn đóng gói (build) một image Docker từ các thành phần của project. Copy đoạn code bên dưới .git .gitignore .dockerignore .gradle .idea Dockerfile README.md Tạo file Dockerfile Tạo file Dockerfile và copy đoạn code bên dưới FROM eclipse-temurin:21-jdk-alpine VOLUME /tmp ARG DEPENDENCY=build/libs COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib COPY ${DEPENDENCY}/META-INF /app/META-INF COPY ${DEPENDENCY}/BOOT-INF/classes /app EXPOSE 8081 ENTRYPOINT [\u0026#34;java\u0026#34;, \u0026#34;-cp\u0026#34;, \u0026#34;app:app/lib/*\u0026#34;, \u0026#34;com.firstcloudjourney.productsservice.ProductsserviceApplication\u0026#34;] Generate docker image Tiếp theo chúng ta sẽ cấu hình trên intelliJ để generate Docker image Nhấn vào biểu tượng Run, chọn new run configuration Một popup hiện lên chúng ta sẽ cấu hình như sau Với Image Tag, nhập productsservice:1.0.0 Nhấn Modify Opition chọn Build options Khi Build options hiên ra, nhập --platform linux/amd64 Tiếp theo chúng ta cần cấu hình before launch Nhấn vào icon + và chọn run gradle task Sau đó 1 pop up hiên lên như bên dưới Trong pop up select gradle task Với Gradle project chọn productsservice Với Task chọn unpack task chúng ta đã thêm trước đó Chọn Ok Sau khi trở lại pop up edit configuration nhấn apply build ứng dụng sử dụng bootjar Tiếp theo chúng ta sẽ build ứng dụng bằng cách sử dụng bootjar từ gradle Chọn biểu tượng gradle Chọn task theo sau đó là build và nhấn bootjar để build ứng dụng Kiểm tra file ứng dụng chúng ta đã buid theo đường dẫn build/libs Gennerate docker image Bây giờ chúng ta sẽ tạo Docker image từ ứng dụng chúng ta đã build Nhấn vào biểu tượng Run ở DockerFile và chọn Build image for \u0026lsquo;DockerFile\u0026rsquo; Hãy đảm bảo bạn đã mở docker desktop để có thể build image thành công\nSau khi tạo image thành công chúng ta có thể thấy productsservice:1.0.0 đã được tạo ra "
},
{
	"uri": "//localhost:1313/vi/8-createdynamodb/8.4-getbyid/",
	"title": "Tạo REST operation để GET product bằng ID",
	"tags": [],
	"description": "",
	"content": "Tạo REST operation để GET product bằng ID Chúng ta có thể tạo nhanh GET method bằng ID bằng cách copy lại PUT method đã tạo và thay PUT bằng GET // GET /products/{id} productIdResource.addMethod(\u0026#34;GET\u0026#34;, new Integration( IntegrationProps.builder() .type(IntegrationType.HTTP_PROXY) .integrationHttpMethod(\u0026#34;GET\u0026#34;) .uri(\u0026#34;http://\u0026#34; + apiStackProps.networkLoadBalancer().getLoadBalancerDnsName() + \u0026#34;:8080/api/products/{id}\u0026#34;) .options(IntegrationOptions.builder() .vpcLink(apiStackProps.vpcLink()) .connectionType(ConnectionType.VPC_LINK) .requestParameters(productIdIntegrationParameters) .build()) .build()), MethodOptions.builder() .requestParameters(productIdMethodParameters) .build()); "
},
{
	"uri": "//localhost:1313/vi/4-createvpc/",
	"title": "Tạo VPC và NAT gateway bằng cách sử dụng AWS CDK",
	"tags": [],
	"description": "",
	"content": "Trong phần này chúng ta sẽ tạo VPC và NAT gateway bằng cách sử dụng AWS CDK\n"
},
{
	"uri": "//localhost:1313/vi/9-intrumentingecs/9.4-testimplement/",
	"title": "Testing the implementation",
	"tags": [],
	"description": "",
	"content": "Testing the implementation Quay trở là productsservice project. Đóng gói project bằng jar trong Grade Mở DockerFile và tạo image tag là productsservice:1.3.0 Sau khi hoàn thành buid Docker Image. Push nó lên ECR Repository với Remote Tag là 1.3.0 Trở lại FCJ2024_CDK project thay đổi image tag của fargateTaskDefinition.addContainer là 1.3.0 Deploy service bằng dòng lệnh cdk deploy --all --require-approval never Sau khi hoành thành deploy. Chúng ta truy cập vào giao diện ECS chọn Task. Sau đó chọn 1 task bất kỳ trong 2 task đang chạy. Trong giao diện task vừa được chọn. Ta có thể thấy một container phụ (sidecar) tên XRayProductsService đang chạy cùng với productsService container Tiếp theo chúng ta sẽ test API trên postman để kiểm tra Đo lường dịch vụ AWS ECS trên AWS X-ray Truy cập vào giao diện CloudWatch chọn Trace Map để xem được đường đi của request Cuối cùng để xem thông tin do lường của ECS chúng ta chọn biểu tượng ECS trên trace map Tượng tự với DynamoDB Mở Postman tạo phương thức Post để tạo một product mới "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.5-rundockerlocal/",
	"title": "Chạy Docker image trên máy local",
	"tags": [],
	"description": "",
	"content": "Chạy Docker image trên máy local Nhấp chuột phải vào image productsservice:1.0.0 chúng ta đã tạo trước đó và chọn Create Container. Pop up Docker image configuration hiện lên chúng ta chọn Run và terminal sẽ run Cấu hình docker container Trong giao diên services chọn tab Dashboard và sau đó chọn add Ports Popup Port bindings hiện lên ta chọn modify options chọn Host IP Nhập 0.0.0.0 vào Host IP Tương tự như trên lần lượt cấu hình host port là 8081 và protocol là TCP Với \u0026ndash;publish nhập 8081 và chọn Recreate container\nTest ứng dụng trên postman Chạy project và test trên postman bằng cách tạo request HTTP GET với đường dẫn http://localhost:8081/api/products "
},
{
	"uri": "//localhost:1313/vi/5-createecs/",
	"title": "Tạo ECS bằng cách sử dụng AWS CDK",
	"tags": [],
	"description": "",
	"content": "Trong phần này chúng ta sẽ tạo ECS cluster, ECS infrastructure và ECS service "
},
{
	"uri": "//localhost:1313/vi/8-createdynamodb/8.5-deletebyid/",
	"title": "Tạo REST operation để DELETE product bằng ID",
	"tags": [],
	"description": "",
	"content": "Tạo REST operation để DELETE product bằng ID Chúng ta có thể tạo nhanh DELETE method bằng ID bằng cách copy lại PUT method đã tạo và thay PUT bằng DELETE productIdResource.addMethod(\u0026#34;DELETE\u0026#34;, new Integration( IntegrationProps.builder() .type(IntegrationType.HTTP_PROXY) .integrationHttpMethod(\u0026#34;DELETE\u0026#34;) .uri(\u0026#34;http://\u0026#34; + apiStackProps.networkLoadBalancer().getLoadBalancerDnsName() + \u0026#34;:8080/api/products/{id}\u0026#34;) .options(IntegrationOptions.builder() .vpcLink(apiStackProps.vpcLink()) .connectionType(ConnectionType.VPC_LINK) .requestParameters(productIdIntegrationParameters) .build()) .build()), MethodOptions.builder() .requestParameters(productIdMethodParameters) .build()); "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.5-addlistenteralb/",
	"title": "Thêm Listener vào Application Load Balancer",
	"tags": [],
	"description": "",
	"content": "Thêm Listener vào Application Load Balancer Khởi tạo ApplicationListener ApplicationListener applicationListener = productsServiceProps.applicationLoadBalancer() Thêm 1 listener với id là ProductsServiceAlbListener và khởi tạo ApplicationListenerProps .addListener(\u0026#34;ProductsServiceAlbListener\u0026#34;, ApplicationListenerProps.builder() .build()); Tiếp theo cho ta sẽ cho ALB listener trên port 8081 và sử dụng giao thức HTTP .port(8081) .protocol(ApplicationProtocol.HTTP) Cuối cùng thêm applicationListener vào Application Load Balancer .loadBalancer(productsServiceProps.applicationLoadBalancer()) "
},
{
	"uri": "//localhost:1313/vi/5-createecs/5.5-organizeanddeploystack/",
	"title": "Tổ chức và deploy NLB Stack",
	"tags": [],
	"description": "",
	"content": "Tổ chức và deploy NLB Stack Mở file root Fcj2024CdkApp Tạo NLB Stack với id là Nlb bằng đoạn code NlbStack nlbStack = new NlbStack(app, \u0026#34;Nlb\u0026#34;, StackProps.builder() .build(),); Truyền VPC đã tạo trước đó cho ClusterStackProps của ECS stack new NlbStackProps(vpcStack.getVpc()) Thêm environmen và Tags cho NLB Stack .env(environment) .tags(infraTags) Vì NLB cần có VPC để tạo. Hãy thêm phụ thuộc để đảm bảo rằng VPC được tạo hoàn thành trước khi tạo NLB nlbStack.addDependency(vpcStack); Deloy NLB bằng AWS CDK Deploy NLB bằng AWS CDK cdk deploy --all --require-approval never Kiểm ta AWS resource đã tạo Trong giao diện AWS console nhập EC2 Trong giao diện EC2 chọn Load balancers ta có thể thấy NLB và ALB đã được tạo Trong giao diện EC2. Nhập API gateway vào than tìm kiếm và chọn API Gateway Trong gia diện API Gateway chọn VPC links ta có thể thấy VPC link đã được tạo thành công "
},
{
	"uri": "//localhost:1313/vi/8-createdynamodb/8.6-configdynamodb/",
	"title": "Cấu hình DynamoDB",
	"tags": [],
	"description": "",
	"content": "Thêm dependencies SDK AWS vào project ProductsService Mở file build.gradle và thêm dependencies SDK AWS như sau implementation(platform(\u0026#34;software.amazon.awssdk:bom:2.21.15\u0026#34;)) implementation(\u0026#34;software.amazon.awssdk:dynamodb\u0026#34;) implementation(\u0026#34;software.amazon.awssdk:dynamodb-enhanced\u0026#34;) Tạo products model để hiển thị nó trong bảng DynomoDB mới Trong thư mục products tạo một thư mục mới tên là Models và sau đó tạo file java mới tên Product.java Tạo model với đoạn code bên dưới @DynamoDbBean public class Product { private String id; private String productName; private String code; private float price; private String model; private String productUrl; @DynamoDbPartitionKey public String getId() { return id; } public void setId(String id) { this.id = id; } public String getProductName() { return productName; } public void setProductName(String productName) { this.productName = productName; } public String getCode() { return code; } public void setCode(String code) { this.code = code; } public float getPrice() { return price; } public void setPrice(float price) { this.price = price; } public String getModel() { return model; } public void setModel(String model) { this.model = model; } public String getProductUrl() { return productUrl; } public void setProductUrl(String productUrl) { this.productUrl = productUrl; } } Tạo DynamoDB config class Tạo một folder mới tên config sau đó tạo một file mới tên là DynamoDBConfig.java và thêm @Configuration một annotation của Spring, dùng để chỉ định rằng class này chứa các bean definition cho container của Spring. Class này được xem như một nguồn cấu hình. @Configuration public class DynamoDBConfig { } Tạo Một biến instance để lưu trữ thông tin vùng (region) của AWS, giá trị của nó được inject vào từ property aws.region trong file cấu hình application.properties @Value(\u0026#34;${aws.region}\u0026#34;) private String awsRegion; Mở file application.properties để cấu hình khu vực là singgapore aws.region=ap-southeast-1 Quay trở lại file DynamoDBConfig tạo phương thức dynamoDbAsyncClient để tạo và cấu hình một DynamoDbAsyncClient, một client không đồng bộ để tương tác với AWS DynamoDB @Bean @Primary public DynamoDbAsyncClient dynamoDbAsyncClient() { return DynamoDbAsyncClient.builder() .credentialsProvider(DefaultCredentialsProvider.create()) .region(Region.of(awsRegion)) .overrideConfiguration(ClientOverrideConfiguration.builder() .addExecutionInterceptor(new TracingInterceptor()) .build()) .build(); } Thêm phương thức dynamoDbEnhancedAsyncClient để tạo và cấu hình một DynamoDbEnhancedAsyncClient, là phiên bản nâng cao của client không đồng bộ để làm việc với AWS DynamoDB. @Bean @Primary public DynamoDbEnhancedAsyncClient dynamoDbEnhancedAsyncClient() { return DynamoDbEnhancedAsyncClient.builder() .dynamoDbClient(dynamoDbAsyncClient()) .build(); } DynamoDbEnhancedAsyncClient cung cấp các API đơn giản hơn và dễ sử dụng hơn so với DynamoDbAsyncClient thông thường, tập trung vào việc làm việc với các bảng và mô hình dữ liệu trong DynamoDB theo cách trừu tượng hơn và chi tiết hơn. Sử dụng client nâng cao này giúp giảm bớt phần nào độ phức tạp khi tương tác với DynamoDB, đặc biệt là khi làm việc với các hoạt động CRUD (Tạo, Đọc, Cập nhật, Xóa) trên dữ liệu.\n"
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.6-createfagateservice/",
	"title": "Tạo AWS Fargate service",
	"tags": [],
	"description": "",
	"content": "Tạo AWS Fargate service Khởi tạo FargateService trong ProductsServiceStack contructor với id là ProductsService FargateService fargateService = new FargateService(this, \u0026#34;ProductsService\u0026#34;, FargateServiceProps.builder() .build()); Thêm service name là ProductsService .serviceName(\u0026#34;ProductsService\u0026#34;) Tiếp theo chúng ta cần thêm cluster đã tạo trước đó để tạo fargate service .cluster(productsServiceProps.cluster()) Ngoài cluster, chúng ta cần có task definition để tạo fragate. Chúng ta sẽ dùng fargateTaskDefinition đã tạo bên trên .taskDefinition(fargateTaskDefinition) Tiếp theo chúng ta sẽ khai báo bao nhiêu instance chúng ta muốn sử dụng. Trong workshop này chúng ta sẽ dử dụng 2 .desiredCount(2) Tiếp theo để giữ fargate trong private subnet nối bên ngoài thông qua NAT Gateway chúng ta sẻ không thêm public IP .assignPublicIp(false) Ngoài ra nếu trong phần tạo PVC bạn không tạo NAT Gateway, bạn có thể làm như sau .assignPublicIp(true) Đừng làm trong môi trường production\nECS service của chúng ta cần permission để pull image từ ECR repository. Vì vậy chúng ta cần phải cấp quyền như sau productsServiceProps.repository().grantPull(Objects.requireNonNull(fargateTaskDefinition.getExecutionRole())); Cuối cùng 1 đều quan trọng nữa là chúng ta cần định nghĩa là service của chúng ta chấp nhận requests từ http port 8081 fargateService.getConnections().getSecurityGroups().get(0).addIngressRule(Peer.anyIpv4(), Port.tcp(8081)); "
},
{
	"uri": "//localhost:1313/vi/6-createservice/",
	"title": "Tạo ECS service với CDK",
	"tags": [],
	"description": "",
	"content": "Trong phần này chúng ta sẽ tạo ECS Service bằng CDK. Trong workshop này chúng ta sẽ tạo ProductService "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.7-configtargergroup/",
	"title": "Cấu hình AWS ALB Target group và cơ chế health check",
	"tags": [],
	"description": "",
	"content": "Cầu hình AWS ALB Target group và cơ chế health check Trước tiên tạo taget group từ applicationListener bằng phương thức .addTargets với ID là ProductsServiceAlbTarget applicationListener.addTargets(\u0026#34;ProductsServiceAlbTarget\u0026#34;, AddApplicationTargetsProps.builder() .build() ); Đặt tên cho target group là productsServiceAlb .targetGroupName(\u0026#34;productsServiceAlb\u0026#34;) Tiếp theo chúng ta sẽ tạo port 8001 để Load Balancer gửi traffic đến và dùng giao thức HTT để giao tiếp với các target .port(8081) .protocol(ApplicationProtocol.HTTP) Tiếp thep ta cần thêm danh sách các service Fargate vào target .targets(Collections.singletonList(fargateService)) Tiếp theo chúng ta sẽ định nghĩa độ trễ cho phép là 30 giây trước khi Load Balancer hủy bỏ một target khi nó bị đánh dấu là không khả dụng .deregistrationDelay(Duration.seconds(30)) Tiếp theo chúng ta sẽ cấu hình health check và bât tính năng health check để đảm bảo rằng các target đang hoạt động đúng cách. .healthCheck(HealthCheck.builder() .enabled(true) .build()) Kế tiếp chúng ta sẽ cấu hình khoảng thời gian giữa các lần kiểm tra sức khỏe là 30 giây và thời gian tối đa để chờ đợi phản hồi từ một target trong mỗi lần kiểm tra là 10 giây .interval(Duration.seconds(30)) .timeout(Duration.seconds(10)) Cuối cùng chúng ta sẽ khai báo đường dẫn(endpoint) được sử dụng để kiểm tra sức khỏe của các target là /actuator/health và port 8081 được sử dụng trong health check để giao tiếp với các target "
},
{
	"uri": "//localhost:1313/vi/7-createapigateway/",
	"title": "Tạo API Gateway với CDK",
	"tags": [],
	"description": "",
	"content": "Trong phần này chúng ta sẽ tạo API Gateway bằng CDK "
},
{
	"uri": "//localhost:1313/vi/8-createdynamodb/8.7-createcontroller/",
	"title": "Tạo product repository",
	"tags": [],
	"description": "",
	"content": "Tạo product repository Trong thư mục products tạo một thư mục mới tên là repositories. Sau đó tạo một file mới tên là ProductsRepository.java Dùng @Repository để ánh dấu lớp ProductsRepository là một bean repository trong Spring để quản lý truy xuất dữ liệu. Thêm 2 trường là DynamoDbEnhancedAsyncClient dynamoDbEnhancedAsyncClientt và DynamoDbAsyncTable productsTable với: private final DynamoDbEnhancedAsyncClient dynamoDbEnhancedAsyncClient: Đây là một trường (field) final để lưu trữ một instance của DynamoDbEnhancedAsyncClient, được sử dụng để tương tác bất đồng bộ với DynamoDB. private DynamoDbAsyncTable productsTable: Đây là một trường (field) để lưu trữ một bảng DynamoDB cho các đối tượng Product dưới dạng bất đồng bộ. private final DynamoDbEnhancedAsyncClient dynamoDbEnhancedAsyncClient; private DynamoDbAsyncTable\u0026lt;Product\u0026gt; productsTable; Tạo constructor trong lớp ProductsRepository với Thêm @Autowired là một annotation của Spring được sử dụng để tự động inject các dependency vào constructor của lớp ProductsRepository. Tạo một tham chiếu DynamoDbEnhancedAsyncClient dynamoDbEnhancedAsyncClient được Spring inject vào constructor. Đối tượng này sẽ được sử dụng để tương tác với DynamoDB. Tạo tham chiếu @Value(\u0026quot;${aws.productsddb.name}\u0026quot;) String productsDdbName là một annotation của Spring để inject giá trị của thuộc tính từ file cấu hình application.properties Trong trường hợp này, nó sẽ inject giá trị của thuộc tính có tên là \u0026ldquo;aws.productsddb.name\u0026rdquo; vào biến productsDdbName. Đây là tên của bảng DynamoDB mà ProductsRepository sẽ tương tác. @Autowired public ProductsRepository( DynamoDbEnhancedAsyncClient dynamoDbEnhancedAsyncClient, @Value(\u0026#34;${aws.productsddb.name}\u0026#34;) String productsDdbName) {} Khởi tại dynamoDbEnhancedAsyncClient để gán giá trị của dynamoDbEnhancedAsyncClient được inject từ Spring vào biến instance this.dynamoDbEnhancedAsyncClient. this.dynamoDbEnhancedAsyncClient = dynamoDbEnhancedAsyncClient; Khởi tạo productsTable sử dụng dynamoDbEnhancedAsyncClient để khởi tạo productsTable. Phương thức table() của dynamoDbEnhancedAsyncClient được gọi với hai đối số: productsDdbName: Đây là tên của bảng DynamoDB mà ProductsRepository sẽ tương tác. TableSchema.fromBean(Product.class): Đối số này tạo ra một schema cho bảng DynamoDB dựa trên cấu trúc của lớp Product. Schema này xác định cách DynamoDB lưu trữ và đọc dữ liệu từ các đối tượng Product. this.productsTable = dynamoDbEnhancedAsyncClient .table(productsDdbName, TableSchema.fromBean(Product.class)); Tiếp theo, tạo phương thức để lấy tất cả các mục trong bảng DynamoDB. productsTable.scan() là một hoạt động quét (scan) trên bảng DynamoDB, trả về tất cả các mục trong bảng public PagePublisher\u0026lt;Product\u0026gt; getAll() { //DO NOT DO THIS PRODUCTION return productsTable.scan(); } Đừng dùng scan trong môi trường production vì việc quét toàn bộ bảng DynamoDB không được khuyến khích trong môi trường sản xuất do tiềm ẩn về hiệu suất và chi phí (cost) của việc này. Quét toàn bộ bảng có thể làm giảm hiệu suất hệ thống đối với các bảng lớn.\nTạo phương thức getById nhận vào một productId và trả về một CompletableFuture, đại diện cho kết quả của việc lấy một mục Product từ bảng DynamoDB dựa trên productId. Với productsTable.getItem() là một hoạt động lấy mục (get item) từ bảng DynamoDB. Với Key.builder().partitionValue(productId).build() xây dựng một Key với giá trị partition key (productId) để truy xuất mục tương ứng từ bảng. public CompletableFuture\u0026lt;Product\u0026gt; getById(String productId) { return productsTable.getItem(Key.builder() .partitionValue(productId) .build()); } Tạo phương thức create,phương thức này nhận vào một đối tượng Product và trả về một CompletableFuture, đại diện cho kết quả của việc tạo mới một mục Product trong bảng DynamoDB. Với productsTable.putItem(product) là một hoạt động thêm mục (put item) vào bảng DynamoDB. Phương thức này sẽ đưa product vào bảng và trả về một CompletableFuture để xử lý kết quả một cách bất đồng bộ. public CompletableFuture\u0026lt;Void\u0026gt; create(Product product) { return productsTable.putItem(product); } Tạo phương thức deleteById, phương thức này nhận vào một productId và trả về một CompletableFuture, đại diện cho kết quả của việc xóa một mục Product từ bảng DynamoDB dựa trên productId. Với productsTable.deleteItem() là một hoạt động xóa mục (delete item) từ bảng DynamoDB Với Key.builder().partitionValue(productId).build() xây dựng một Key với giá trị partition key (productId) để xác định mục cần xóa từ bảng. public CompletableFuture\u0026lt;Product\u0026gt; deleteById(String productId) { return productsTable.deleteItem(Key.builder() .partitionValue(productId) .build()); } Cuối cùng tạo phương thức update, thức này được sử dụng để cập nhật một mục Product trong bảng DynamoDB. Trước khi thực hiện cập nhật, product.setId(productId) được sử dụng để đặt lại ID của product thành productId được cung cấp. Sử dụng productsTable.updateItem(), trong đó UpdateItemEnhancedRequest.builder(Product.class).item(product) xây dựng một yêu cầu cập nhật dữ liệu của product. Điều kiện cập nhật được chỉ định bằng cách sử dụng conditionExpression(), trong đó chỉ ra rằng thuộc tính id của product phải tồn tại trước khi cập nhật có thể được thực hiện. Phương thức trả về một CompletableFuture để xử lý kết quả cập nhật một cách bất đồng bộ. public CompletableFuture\u0026lt;Product\u0026gt; update(Product product, String productId) { product.setId(productId); return productsTable.updateItem( UpdateItemEnhancedRequest.builder(Product.class) .item(product) .conditionExpression(Expression.builder() .expression(\u0026#34;attribute_exists(id)\u0026#34;) .build()) .build() ); } "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.8-confignlb/",
	"title": "Cấu hình AWS Network Load Balancer",
	"tags": [],
	"description": "",
	"content": "Tạo NetworkListener Trước tiên chùng ta cần khởi tạo đối tượng NetworkListener NetworkListener networkListener = productsServiceProps.networkLoadBalancer() .addListener(\u0026#34;ProductsServiceNlbListener\u0026#34;, BaseNetworkListenerProps.builder() .build()); Bây giờ, chúng ta sẽ cấu hình cho networkListener lắng nghe trên port 8081 .port(8081) Sử dụng protocol là giao thức mà listener sử dụng để lắng nghe các kết nối. Ở đây chúng ta dùng TCP .protocol(software.amazon.awscdk.services.elasticloadbalancingv2.Protocol.TCP) software.amazon.awscdk.services.elasticloadbalancingv2.Protocol.TCP: Đây là cách để chỉ định giao thức TCP thông qua CDK. Protocol.TCP là một hằng số trong CDK để đại diện cho giao thức TCP.\nCấu hình NLB target group Sử dụng phương thức addTargets được gọi trên đối tượng networkListener để thêm các target (đích) mới cho listener đã được cấu hình trước đó trên NLB. networkListener.addTargets(\u0026#34;ProductsServiceNlbTarget\u0026#34;, AddNetworkTargetsProps.builder() .build() ); Tiếp theo cho ta sẽ cho các kết nối sẽ được gửi đến cổng 8081 trên các target. .port(8081) Để kết nối đến các target ta sử dụng giao thức TPC .protocol(software.amazon.awscdk.services.elasticloadbalancingv2.Protocol.TCP) Tiếp theo tạo tên của nhóm target (target group) mà các target sẽ được thêm vào là productsServiceNlb .targetGroupName(\u0026#34;productsServiceNlb\u0026#34;) Tiếp theo chúng ta sẽ chỉ định danh sách các target cụ thể cần được thêm vào bằng phương thức targets .targets(Collections.singletonList()) Tạo ra một target sử dụng cho dịch vụ Fargate. Một target Fargate sẽ được tạo để xử lý các kết nối gửi đến từ NLB. .targets(Collections.singletonList( fargateService.loadBalancerTarget(LoadBalancerTargetOptions.builder() .build()) )) Tiếp theo chúng ta sẽ định nghĩa tên của container trong dịch vụ Fargate mà các kết nối sẽ được gửi đến là productsService .targets(Collections.singletonList( fargateService.loadBalancerTarget(LoadBalancerTargetOptions.builder() .containerName(\u0026#34;productsService\u0026#34;) .build()) )) Cuối cùng cấu hình port 8081 của container trong dịch vụ Fargate mà các kết nối sẽ được gửi đến và giao thức là TCP .targets(Collections.singletonList( fargateService.loadBalancerTarget(LoadBalancerTargetOptions.builder() .containerName(\u0026#34;productsService\u0026#34;) .containerPort(8081) .protocol(Protocol.TCP) .build()) )) "
},
{
	"uri": "//localhost:1313/vi/8-createdynamodb/",
	"title": "Tạo bảng DynamoDB products bằng AWS CDK",
	"tags": [],
	"description": "",
	"content": "Trong phần này chúng ta sẽ tạo bảng DynamoDb product bằng AWS CDK "
},
{
	"uri": "//localhost:1313/vi/8-createdynamodb/8.8-createcontroller/",
	"title": "Tạo controller",
	"tags": [],
	"description": "",
	"content": "Tạo productDTO Tạo một thư mục tên dto và một file mới có tên là ProductDto Tạo ProductDTO như sau public record ProductDto( String id, String name, String code, float price, String model, @JsonInclude(JsonInclude.Include.NON_NULL) String url ) { public ProductDto(Product product) { this(product.getId(), product.getProductName(), product.getCode(), product.getPrice(), product.getModel(), product.getProductUrl()); } static public Product toProduct(ProductDto productDto) { Product product = new Product(); product.setId(product.getId()); product.setProductName(productDto.name); product.setCode(productDto.code()); product.setModel(productDto.model()); product.setPrice(productDto.price()); product.setProductUrl(productDto.url()); return product; } } Tạo controller Trong class ProductsController khởi tạo productsRepository Khai báo productsRepository Là một dependency injection thông qua constructor, được sử dụng để truy xuất dữ liệu từ các sản phẩm trong cơ sở dữ liệu Khởi tạo productsRepository trong contructor sử dụng @Autowired, cho phép Spring tự động inject productsRepository vào controller. private final ProductsRepository productsRepository; @Autowired public ProductsController(ProductsRepository productsRepository) { this.productsRepository = productsRepository; } Tạo phương thức getAllProducts .Phương thức này được đánh dấu bởi @GetMapping, chỉ xử lý các HTTP GET request tới đường dẫn được chỉ định (/products). Phương thức này bao gồm Ghi log thông tin \u0026ldquo;Get all products\u0026rdquo;. Tạo một danh sách rỗng productsDto để lưu trữ các đối tượng ProductDto. Sử dụng productsRepository.getAll().items().subscribe(\u0026hellip;) để lấy danh sách sản phẩm từ repository. Đối với mỗi product được lấy ra từ repository, nó tạo một ProductDto tương ứng và thêm vào productsDto Cuối cùng, phương thức trả về một ResponseEntity\u0026lt;List\u0026gt; chứa danh sách productsDto đã tạo, với mã trạng thái HttpStatus.OK. @GetMapping public ResponseEntity\u0026lt;List\u0026lt;ProductDto\u0026gt;\u0026gt; getAllProducts() { LOG.info(\u0026#34;Get all products\u0026#34;); List\u0026lt;ProductDto\u0026gt; productsDto = new ArrayList\u0026lt;\u0026gt;(); productsRepository.getAll().items().subscribe(product -\u0026gt; { productsDto.add(new ProductDto(product)); }).join(); return new ResponseEntity\u0026lt;\u0026gt;(productsDto, HttpStatus.OK); } Tạo phương thức getProductById Phương thức này được đánh dấu bởi @GetMapping(\u0026quot;{id}\u0026quot;), có nghĩa là nó sẽ xử lý các HTTP GET request tới \u0026ldquo;/products/{id}\u0026rdquo;, trong đó {id} là một path variable Phương thức này lấy id từ đường dẫn và sử dụng productsRepository.getById(id).join() để đợi và lấy ra Product từ repository Nếu product khác null, nó trả về ProductDto của product đó với mã trạng thái HttpStatus.OK. Nếu product là null, nó trả về thông báo lỗi \u0026ldquo;Product not found\u0026rdquo; với mã trạng thái HttpStatus.NOT_FOUND. @GetMapping(\u0026#34;{id}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; getProductById(@PathVariable(\u0026#34;id\u0026#34;) String id) { Product product = productsRepository.getById(id).join(); if (product != null) { return new ResponseEntity\u0026lt;\u0026gt;(new ProductDto(product), HttpStatus.OK); } else { return new ResponseEntity\u0026lt;\u0026gt;( \u0026#34;Product not found\u0026#34;, HttpStatus.NOT_FOUND); } } Tạo phương thức createProduct. Phương thức này được đánh dấu bởi @PostMapping, xử lý các HTTP POST request tới \u0026ldquo;/products\u0026rdquo;. Phương thức này tạo một Product từ ProductDto được gửi lên (productDto), gán một id mới bằng UUID, sau đó lưu productCreated vào productsRepository bằng productsRepository.create(productCreated).join(). Sau khi tạo sản phẩm thành công, nó ghi log thông tin về sản phẩm được tạo và trả về ProductDto của sản phẩm đó với mã trạng thái HttpStatus.CREATED. @PostMapping public ResponseEntity\u0026lt;ProductDto\u0026gt; createProduct(@RequestBody ProductDto productDto) { Product productCreated = ProductDto.toProduct(productDto); productCreated.setId(UUID.randomUUID().toString()); productsRepository.create(productCreated).join(); LOG.info(\u0026#34;Product created - ID: {}\u0026#34;, productCreated.getId()); return new ResponseEntity\u0026lt;\u0026gt;(new ProductDto(productCreated), HttpStatus.CREATED); } Tạo phương thức deleteProductById. Phương thức này được đánh dấu bởi @DeleteMapping(\u0026quot;{id}\u0026quot;), xử lý các HTTP DELETE request tới \u0026ldquo;/products/{id}\u0026rdquo; Phương thức này sử dụng productsRepository.deleteById(id).join() để xóa sản phẩm từ repository. Nếu sản phẩm đã được xóa thành công (productDeleted khác null), nó ghi log thông tin về sản phẩm đã bị xóa và trả về ProductDto của sản phẩm đó với mã trạng thái HttpStatus.OK. Nếu không tìm thấy sản phẩm để xóa (productDeleted là null), nó trả về thông báo lỗi \u0026ldquo;Product not found\u0026rdquo; với mã trạng thái HttpStatus.NOT_FOUND. @DeleteMapping(\u0026#34;{id}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; deleteProductById(@PathVariable(\u0026#34;id\u0026#34;) String id) { Product productDeleted = productsRepository.deleteById(id).join(); if (productDeleted != null) { LOG.info(\u0026#34;Product deleted - ID: {}\u0026#34;, productDeleted.getId()); return new ResponseEntity\u0026lt;\u0026gt;(new ProductDto(productDeleted), HttpStatus.OK); } else { return new ResponseEntity\u0026lt;\u0026gt;(\u0026#34;Product not found\u0026#34;, HttpStatus.NOT_FOUND); } } Tạo phương thức updateProduct. Phương thức này được đánh dấu bởi @PutMapping(\u0026quot;{id}\u0026quot;), xử lý các HTTP PUT request tới \u0026ldquo;/products/{id}\u0026rdquo;. Phương thức này cập nhật thông tin của một sản phẩm dựa trên id được chỉ định. Nó sử dụng productsRepository.update(\u0026hellip;).join() để cập nhật sản phẩm trong repository Nếu sản phẩm được cập nhật thành công, nó ghi log thông tin về sản phẩm đã được cập nhật và trả về ProductDto của sản phẩm đó với mã trạng thái HttpStatus.OK. Nếu không tìm thấy sản phẩm để cập nhật (productsRepository.update(\u0026hellip;) ném ra một CompletionException), nó trả về thông báo lỗi \u0026ldquo;Product not found\u0026rdquo; với mã trạng thái HttpStatus.NOT_FOUND. @PutMapping(\u0026#34;{id}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; updateProduct(@RequestBody ProductDto productDto, @PathVariable(\u0026#34;id\u0026#34;) String id) { try { Product productUpdated = productsRepository .update(ProductDto.toProduct(productDto), id).join(); LOG.info(\u0026#34;Product updated - ID: {}\u0026#34;, productUpdated.getId()); return new ResponseEntity\u0026lt;\u0026gt;(new ProductDto(productUpdated), HttpStatus.OK); } catch (CompletionException e) { return new ResponseEntity\u0026lt;\u0026gt;(\u0026#34;Product not found\u0026#34;, HttpStatus.NOT_FOUND); } } "
},
{
	"uri": "//localhost:1313/vi/8-createdynamodb/8.9-deploy/",
	"title": " Thực hiện deploy để kiểm thử",
	"tags": [],
	"description": "",
	"content": "Thực hiện deploy để kiểm thử\u0026quot; Trong productsservice project chúng ta chọn biểu tượng Grade và chọn jar để đóng gói project Tiếp theo chúng ta cần tạo một image mới. Mở DockerFile chọn Edit dockerfile Trong giao diện Edit Dockerfile. Thay đổi image tag là 1.1.0 để tạo một Docker image mới sau chọn chọn Run Push image vừa tạo lên ECR Repository bằng cách mở AWS Toolkit chọn ERC và sau đó chọn productsservice. Cuối cùng click phải chọn Push to Repository Trong popup Push to ECR chọn Local image là productsservice:1.0.0 và Remote Tag là 1.1.0 và chọn Push Kiểm tra image vừa push trên giao điện ECR Mở FCJ2024_CDK project. Sau đó mở file ProductsServiceStack và thay đổi tag trong phần fargateTaskDefinition.addContainer là 1.1.0 Tiếp theo, sử dụng cdk deploy --all --require-approval never Tiếp theo ta cần kiểm tra xem task definition mới của chúng ta có chạy hay không bằng cách mở giao điện ECS chọn CLuster sau đó chọn ECommerce và cuối cùng là chọn task Truy cập giao điện DymanoBD để kiểm tra product table đã được tạo hạy chưa Access the API Gateway interface to verify the created methods.\nIn the API Gateway interface, navigate to Stages and copy the Invoke URL for testing the API in Postman.\nTo add a product using the POST method, open Postman and create a POST request with the endpoint Invoke URL/product.\nNext, pass parameters by selecting Body and choosing raw. Then enter the data in the following format:\n{ \u0026#34;name\u0026#34;: \u0026#34;Product1\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;COD1\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;Model1\u0026#34;, \u0026#34;price\u0026#34;: 10.50 } Press Send to submit the request. Similarly, you can add more product data.\nTiếp theo chúng ta sẽ lấy tất cả product đã tạo bằng phương thức GET với đường dẫn là Invoke URL/product Làm tương tự với các phương thức còn lại.\nNext, retrieve all created products using the GET method with the endpoint Invoke URL/product.\nSimilarly, perform the same steps for the remaining methods.\n"
},
{
	"uri": "//localhost:1313/vi/9-intrumentingecs/",
	"title": "Đo lường dịch vụ AWS ECS với AWS X-Ray",
	"tags": [],
	"description": "",
	"content": "Đo lường dịch vụ AWS ECS với AWS X-Ray "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.9-organizestack/",
	"title": "Tổ chức và deploy Stack",
	"tags": [],
	"description": "",
	"content": "Tổ chức ProductsServiceStack Stack Mở file root Fcj2024CdkApp Tạo và Thiết lập Tags: Tạo ra một Map có tên là productsServiceTags để định nghĩa các tag (nhãn) cho stack và các tài nguyên liên quan. Các tag được lưu trữ dưới dạng cặp key-value trong map. Map\u0026lt;String, String\u0026gt; productsServiceTags = new HashMap\u0026lt;\u0026gt;(); productsServiceTags.put(\u0026#34;team\u0026#34;, \u0026#34;FirstCloudJourney\u0026#34;); productsServiceTags.put(\u0026#34;cost\u0026#34;, \u0026#34;ProductsService\u0026#34;); Tạo Stack ProductsServiceStack ProductsServiceStack productsServiceStack = new ProductsServiceStack(app, \u0026#34;ProductsService\u0026#34;, StackProps.builder() .env(environment) .tags(productsServiceTags) .build(), new ProductsServiceProps( vpcStack.getVpc(), clusterStack.getCluster(), nlbStack.getNetworkLoadBalancer(), nlbStack.getApplicationLoadBalancer(), ecrStack.getProductsServiceRepository())); Thêm Dependency để đảm bảo rằng VPC,Cluster,NLB và ECR được tạo trước khi tạo service productsServiceStack.addDependency(vpcStack); productsServiceStack.addDependency(clusterStack); productsServiceStack.addDependency(nlbStack); productsServiceStack.addDependency(ecrStack); Deloy ProductsService Stack bằng AWS CDK Mở termial và nhập cdk deploy --all --require-approval never Sau khi deploy thành công. Truy cập vào giao diện AWS console. Nhập ECS Trong giao diện ECS ta có thể thấy 1 cluster tên ECommerce đã được tạo cùng với 2 task đang chạy Chọn Cluster ECommerce và sau đó chọn task để xem thông tinh về các task đã tạo "
},
{
	"uri": "//localhost:1313/vi/10-cleanresource/",
	"title": "Cleanup Resources",
	"tags": [],
	"description": "",
	"content": "Cleanup Resources Để xoá resources, chúng ta sử dụng lệnh command sau: cdk deploy --all --require-approval never "
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]