[
{
	"uri": "//localhost:1313/vi/",
	"title": "Deploy Spring Boot applications onto AWS ECS Fargate using AWS CDK.",
	"tags": [],
	"description": "",
	"content": "Sử dụng AWS CDK để triển khai dịch vụ Spring Boot trên AWS ECS Fargate Tổng quan Trong wokshop này, chúng ta sẽ tạo ra một microservices bằng Java 21, sử dụng framework Spring Boot V3 và các container Docker, xây dựng một ứng dụng backend để tương tác với các tài nguyên của Amazon Web Services (AWS). Các tài nguyên này sẽ được tạo trong AWS bằng cách sử dụng AWS Cloud Development Kit (CDK) V2, một cách hiện đại để mô hình hóa và cấu hình cơ sở hạ tầng trong AWS. AWS CDK là một trong những công cụ tốt nhất cho việc quản lý cơ sở hạ tầng dưới dạng mã, hay còn gọi là IaC (Infrastructure as Code), trên AWS.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Workshop này sẽ bao gồm các tài nguyên và công cụ AWS sau đây: AWS ECS: Dịch vụ Elastic Container Service là dịch vụ điều phối container của AWS. Với dịch vụ này, bạn có thể quản lý việc thực thi các container dịch vụ nhỏ dựa trên Docker một cách mạnh mẽ và có khả năng mở rộng. Với AWS Fargate, dịch vụ tính toán không máy chủ dành cho các container từ Amazon Web Services, bạn không cần tạo các máy EC2, giảm chi phí vận hành của các ứng dụng dựa trên container.\nAWS ECR: Với Elastic Container Registry (ECR) từ AWS, bạn có thể tạo các kho lưu trữ riêng để lưu trữ các hình ảnh Docker của các dịch vụ nhỏ.\nAWS VPC: Với Virtual Private Cloud (VPC) từ AWS, bạn có thể bảo vệ cơ sở hạ tầng bằng các mạng con riêng và các chính sách bảo mật mạng cho các quy tắc lưu lượng đi vào và đi ra.\nAWS ALB: Application Load Balancer từ AWS cho phép cân bằng lưu lượng HTTP đến giữa tất cả các phiên bản ứng dụng có sẵn, và với các nhóm mục tiêu tích hợp, mỗi phiên bản có thể được giám sát để chỉ nhận lưu lượng nếu nó đang hoạt động bình thường.\nAPI Gateway REST: Với AWS API Gateway, bạn có thể bảo vệ API REST của ứng dụng, cũng như thực hiện kiểm tra hợp lệ của các tham số query string và nội dung yêu cầu.\nCloudWatch Logs: Trách nhiệm của nó là tập trung các nhật ký ứng dụng và các chỉ số của chúng. Các ứng dụng sẽ được tạo ra trong khóa học này sẽ tạo ra các nhật ký vào CloudWatch Logs theo định dạng JSON, sử dụng thư viện log4j2. Điều này cho phép chúng ta chèn các tham số vào các nhật ký, để được sử dụng trong các truy vấn trong bảng điều khiển AWS CloudWatch Logs Insights.\nCloudWatch Alarms: Với các cảnh báo từ CloudWatch, bạn có thể theo dõi các sự kiện bất thường từ các ứng dụng và tài nguyên AWS.\nCloudWatch Logs: Trách nhiệm của nó là tập trung các nhật ký ứng dụng và các chỉ số của chúng. Các ứng dụng sẽ được tạo ra trong khóa học này sẽ tạo ra các nhật ký vào CloudWatch Logs theo định dạng JSON, sử dụng thư viện log4j2. Điều này cho phép chúng ta chèn các tham số vào các nhật ký, để được sử dụng trong các truy vấn trong bảng điều khiển AWS CloudWatch Logs Insights.\nDynamoDB: DynamoDB là một dịch vụ quản lý cơ sở dữ liệu NoSQL mạnh mẽ và phi quan hệ. Khóa học này giới thiệu việc sử dụng DynamoDB enhanced client từ AWS SDK V2 cho Java, đây là một thư viện cấp cao cho phép ánh xạ các lớp phía máy khách với các bảng DynamoDB.\nSQS: SQS là một dịch vụ hàng đợi cho phép giao tiếp bất đồng bộ giữa các ứng dụng, nhằm trao đổi các thông điệp và sự kiện.\nSNS: Với SNS bạn có thể tạo các chủ đề và xuất bản các thông điệp để được nhận bởi nhiều tài nguyên và ứng dụng.\n"
},
{
	"uri": "//localhost:1313/vi/3-createecr/3.1-createfirststack/",
	"title": "Tạo cloudformation stack đầu tiên",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị cho CDK project Xoá file Fcj2024CdkStack đã được tạo sẵn trước đó Xoá những phần comment không cần thiết Tạo 1 stack mới bằng việc tạo 1 file java mới và đặt tên là EcrStack.java Bằng cách sử dụng CDK, bạn có thể viết mã để tạo các stack và tài nguyên của CloudFormation. Mã của bạn sẽ được biên dịch thành các template CloudFormation tương ứng, sau đó có thể được triển khai bởi CloudFormation như bình thường\nSau khi hoàn thành thành để class EcrStack kế thừa từ lớp Stack của thư viện Amzon CDK Tạo stack contructor Tạo AWS resource thông qua repository Đầu tiên tạo thuộc tính productsServiceRepository bằng dòng lệnh bên dưới\nprivate final Repository productsServiceRepository; Tiếp theo Khởi đạo thuộc tính productsServiceRepository trong contructor\nthis.productsServiceRepository = new Repository(); Để khởi tạo Repository ta thêm các parameter sau this, this đề cập đến đối tượng lớp hiện tại (thường là một CDK stack). \u0026ldquo;ProductsService\u0026rdquo;: Đây là tên duy nhất (ID) của tài nguyên được tạo. Tên này là duy nhất trong phạm vi của một stack CDK. Sau đó tạo ECR Repository properties bằng RepositoryProps.builder().build() builder() là một phương thức tĩnh của lớp RepositoryProps để khởi tạo một đối tượng Builder. Đây là một bước chuẩn bị để thiết lập các thuộc tính cho RepositoryProps. Phương thức build() trên đối tượng Builder được gọi để kết thúc quá trình xây dựng và trả về một đối tượng RepositoryProps hoàn chỉnh với các thuộc tính đã thiết lập. Tạo ECR repository name bằng cách thêm đoạn code .repositoryName(\u0026quot;productsservice\u0026quot;) trước build() Them .removalPolicy(RemovalPolicy.DESTROY) để đảm bảo rằng khi khi xoá cloudformation stack resource của chúng ta cũng sẽ được xoá theo Tiếp theo cho phép override các image tren CER repository bằng việc cho phép IMMUTABLE thông qua đoạn code imageTagMutability(TagMutability.IMMUTABLE) Cho phép tự động xoá image khi xoá ECR bằng cách thêm code autoDeleteImages(true) Tạo phương thức Getter public Repository getProductsServiceRepository() { return productsServiceRepository; } "
},
{
	"uri": "//localhost:1313/vi/5-createecs/5.1-createecscluster/",
	"title": "Tạo ECS cluster",
	"tags": [],
	"description": "",
	"content": "Tạo ECS Cluster stack Mở CDK project tạo stack mới với tên là ClusterStack.java Để tạo ECS stack chúng ta cần VPC mà chúng ta đã tạo trước đó. Nên chúng ta cần tạo 1 record class để truyền VPC vào ECS Stack. Thêm đoạn code bên ngoài class ClusterStack record ClusterStackProps( Vpc vpc ){} Tạo thuộc tính cluster và phương thức getter private final Cluster cluster; public Cluster getCluster() { return cluster; } Tạo constructor public ClusterStack(final Construct scope, final String id, final StackProps props, ClusterStackProps clusterStackProps) { super(scope, id, props); } Khởi tạo đối tượng VPC bằng đoạn code sau trong contructor this.cluster = new Cluster(this, \u0026#34;Cluster\u0026#34;, ClusterProps.builder() .build()); Thêm tên của cluster là ECommerce .clusterName(\u0026#34;ECommerce\u0026#34;) Thêm VPC vào cluster .vpc(clusterStackProps.vpc()) Cuối cùng là set containerInsight bằng true .containerInsights(true) Tổ chức ECS stack in CDK project Mở file root Fcj2024CdkApp Tạo ECS Stack với id là Vpc bằng đoạn code ClusterStack clusterStack = new ClusterStack(app, \u0026#34;Cluster\u0026#34;, StackProps.builder() .build()); Truyền VPC đã tạo trước đó cho ClusterStackProps của ECS stack new ClusterStackProps(vpcStack.getVpc()) Thêm Thêm environmen* và Tags cho ECS Stack .env(environment) .tags(infraTags) Bởi vì ECS cần có VPC nhưng chúng ta không thể biết chắc chắn rằng VPC có được tạo trước CES hay không. Vì vậy hãy thêm một ràng buộc là khi nào việc tạo VPC hoàn thành rồi ECS mới được tạo bằng cách clusterStack.addDependency(vpcStack); Deloy Ecs cluster bằng AWS CDK Để deloy ecs cluster, mở terminal và nhập Ta có thể deploy tất cả các stack bằng cdk deploy --all Ngoài ra chúng ta có thể bỏ qua bước confirm bằng cách cdk deploy --all --require-approval never Deloy Ecs cluster bằng AWS CDK Kiểm tra cluster vừa tạo Truy cập vào AWS console, Nhập ECS, chọn Elastic Container Service\nTrong giao diện ECS, ta có thể thấy 1 cluster tên ECommerce đã được tạo "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.1-createinfrastructureproject/",
	"title": "Tạo infrastructure project with AWS CDK",
	"tags": [],
	"description": "",
	"content": "infrastructure project sử dụng AWS CDK Mở termial tại thư mục bạn muốn tạo project Nhập lệnh sau cdk init app --language java Bài workshop này sẻ sử dụng java. Ngoài ra bạn có thể tạo bằng python hoặc typescipt\nMở IntelliJ IDEA và mở project chúng ta vừa tạo "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.1-createnewstack/",
	"title": "Tạo Stack mới cho product service",
	"tags": [],
	"description": "",
	"content": "Tạo Stack mới cho product service Mở CDK project tạo stack mới với tên là ProductsServiceStack và cho ProductsServiceStack kế thừa lớp Stack của thư viện amazon.awscdk Để tạo ProductsServiceStack chúng ta cần VPC, Cluster, NetworkLoadBalancer, ApplicationLoadBalancer và Repository mà chúng ta đã tạo trước đó. Nên chúng ta cần tạo 1 record class tên là ProductsServiceProps để truyền vào ProductsServiceStack. Thêm đoạn code bên ngoài class ClusterStack record ProductsServiceProps( Vpc vpc, Cluster cluster, NetworkLoadBalancer networkLoadBalancer, ApplicationLoadBalancer applicationLoadBalancer, Repository repository ){} Tạo Contructor public ProductsServiceStack(final Construct scope, final String id, final StackProps props, ProductsServiceProps productsServiceProps) { super(scope, id, props); } "
},
{
	"uri": "//localhost:1313/vi/4-createvpc/4.1-createvpc/",
	"title": "Tạo VPC và Nat gateway",
	"tags": [],
	"description": "",
	"content": "Tạo VPC và Nat gateway Mở CDK project tạo stack mới với tên là VpcStack.java Kế thừa Stack của thư viện awscdk vào tạo constructor Tạo thuộc tính VPC và tạo phương thức getter Thêm thuộc tính bằng đoạn code sau private final Vpc vpc; Tiếp đó chúng ta tạo hàm getter để có thể sử dụng VPC này cho các resource khác public Vpc getVpc() { return vpc; } Khởi tạo đối tượng VPC bằng đoạn code sau trong contructor this.vpc = new Vpc(this, \u0026#34;Vpc\u0026#34;, VpcProps.builder() .build()); Tiếp theo đặt tên cho PVC là ECommerceVPC và số lương Availability Zones là 2 thông qua đoạn code\n.vpcName(\u0026#34;ECommerceVPC\u0026#34;) .maxAzs(2) Nếu bạn muốn VPC của bạn là Public và không sử dụng Nat gateway bạn có thể thêm đoạn code .natGateways(0) Bạn có thể không sử dụng Nate gateway khi làm lab để tiết kiệm chi phí nhưng đừng làm trong môi trường production\n"
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Các bước chuẩn bị Trước tiên, chúng ta sẽ xây dựng một mô hình theo sơ đồ bên dưới để đảm bảo rằng ứng dụng web của chúng ta hoạt động bình thường\nJava Development Kit (JDK) Đầu tiên chúng ta cần cài đặt Java Development Kit (JDK). Trong workshop nảy chúng ta sẽ dùng JDK 21 LTS. Bạn có thể tải tại đường dẫn này Tiếp theo chúng ta cần cài đặt maven. Bạn có thể cài đặt theo hướng dẫn NodeJS để cài dặt AWS CDK CLI chúng ta cần phải cài đặt NodeJS. Truy cập đường dẫn. Tải về phiên bản LTS mới nhất\nKiểm tra NodeJS đã được cài đặt đúng chưa, thực hiện lệnh sau trong terminal\nnode -v Lệnh này sẽ show phiên bản NodeJS đã được cài đặt v18.15.0 Kiểm tra phiên bản NPM đã được cài đặt, thực hiện lệnh sau trong terminal npm -v Command sẽ show phiên bản NPM đã được cài đặt 9.6.2 AWS CLI Truy cập liên kết này và tải về phiên bản mới nhất Sau khi cài đặt hoàn thành mở termial và kiểm tra phiên bản AWS CLI vừa cài đặt, thông qua lênh sau aws --v AWS CDK AWS Cloud Development Kit, or AWS CDK sẽ được sử dụng để xây dựng mã chịu trách nhiệm tạo cơ sở hạ tầng ứng dụng sử dụng dịch vụ AWS. Sau khi cài đặt các gói được đề cập ở trên, hãy thực hiện lệnh sau trong cửa sổ terminal trên hệ điều hành của bạn để cài đặt AWS CDK: npm install -g aws-cdk Kiểm tra CDK đã được cài đặt đúng chưa, thực hiện lệnh sau trong terminal cdk --version Postman Postman là một ứng dụng miễn phí rất hữu ích. Bằng cách sử dụng nó, bạn có thể gửi các yêu cầu tới các ứng dụng được phát triển trong workshop này, bất kể chúng có đang chạy trên máy tính của bạn hay đã được triển khai trên tài khoản AWS của bạn. Tải Postman dựa vào chỉ dẫn sau IntelliJ IDEA Community Edition IDE mà sẽ được sử dụng là IntelliJ IDEA Community Edition, từ công ty JetBrains. Đây là một trong những IDE hiện đại nhất để phát triển trong Java và các ngôn ngữ lập trình khác. Tải IntelliJ IDEA Community Edition thông qua đường dẫn này Docker Desktop Docker Desktop sẽ được sử dụng để tạo image Docker của tất cả các ứng dụng sẽ được tạo bằng nó workshop này trước khi tải image lên AWS Tải docker thông qua đường dẫn "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.2-createectask/",
	"title": "Tạo ECS task definition",
	"tags": [],
	"description": "",
	"content": "Tạo CES task definition Trong ProductsServiceStack contructor khởi tạo đối tượng FargateTaskDefinition FargateTaskDefinition fargateTaskDefinition = new FargateTaskDefinition(this, \u0026#34;TaskDefinition\u0026#34;, FargateTaskDefinitionProps.builder() .build()); Tạo tên group của tất cả các task definition bạn đã tạo .family(\u0026#34;products-service\u0026#34;) Tiếp theo chúng ta định nghĩa số lượng cpu là 512 và memory là 1024 .cpu(512) .memoryLimitMiB(1024) "
},
{
	"uri": "//localhost:1313/vi/5-createecs/5.2-createnlb/",
	"title": "Tạo Network Load Balancer",
	"tags": [],
	"description": "",
	"content": "Tạo Network Load Balancer stack Trong CDK project tạo stack mới với tên là NlbStack.java và sau đó cho class NlbStack kế thừa lớp Stack cửa thư viện amazon.awscdk Để tạo NLB stack chúng ta cần VPC mà chúng ta đã tạo trước đó. Nên chúng ta cần tạo 1 record class tên là NlbStackProps để truyền VPC vào NLB Stack. Thêm đoạn code bên ngoài class ClusterStack record NlbStackProps( Vpc vpc ){} Trong NLB Stack chúng ta sẽ tạo Vpc Link, Network Load Balancer, Application Load Balancer nên trước tiên chúng ta cần tạo 3 thuộc tính ứng với chúng. private final VpcLink vpcLink; private final NetworkLoadBalancer networkLoadBalancer; private final ApplicationLoadBalancer applicationLoadBalancer; Tiếp theo, chúng ta tạo các getter cho 3 thuộc tính trên public VpcLink getVpcLink() { return vpcLink; } public NetworkLoadBalancer getNetworkLoadBalancer() { return networkLoadBalancer; } public ApplicationLoadBalancer getApplicationLoadBalancer() { return applicationLoadBalancer; } Tạo contructor cho class NlbStack public NlbStack(final Construct scope, final String id, final StackProps props, NlbStackProps nlbStackProps) { super(scope, id, props); } Tạo network load balancer Trước tiên chúng ta sẽ tạo network load balancer (NLB). Để tạo NLB chúng ta cần khởi tạo đối tượng networkLoadBalancer trong contructor this.networkLoadBalancer = new NetworkLoadBalancer(this, \u0026#34;Nlb\u0026#34;, NetworkLoadBalancerProps.builder() .build()); Tiếp theo đặt tên cho NLB là ECommerceNlb bằng cách .loadBalancerName(\u0026#34;ECommerceAlb\u0026#34;) Như trong thiết kế trên diagram. Chúng ta sẽ khổng để NLB và ALB ngoài VPC nên chúng ta sẽ làm như sau .internetFacing(false) .vpc(nlbStackProps.vpc()) "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.2-createspingbootproject/",
	"title": "Tạo Spring Boot project",
	"tags": [],
	"description": "",
	"content": "Tạo Spring Boot project Truy câp vào đường dẫn start.spring.io Chọn ngôn ngữ lập trình và phiên bản framework Với Project chọn Gradle - Groovy Với Language chọn Java Với phiên bản Spring Boot chọn 3.2.4 Cấu hình Project Metadata Với Group nhập com.firstcloudjourney Với Artifact nhập productsservice Các phần còn lại sẽ được tự động điền Chọn phiên bản java là 21 Thêm Dependencies Nhấn vào ADD DEPENDENCIES một pop up hiện lên Thêm các package lần lượt là Spring Web và Spring Boot Actuator Tạo project springboot Nhấn GENERATE để tài về project vừa tạo "
},
{
	"uri": "//localhost:1313/vi/3-createecr/3.2-organizestack/",
	"title": "Tổ chức CDK stack in CDK project",
	"tags": [],
	"description": "",
	"content": "Tổ chức CDK stack in CDK project Mở file root Fcj2024CdkApp Tạo ECR Stack bằng đoạn code EcrStack ecrStack = new EcrStack(app, \u0026#34;Ecr\u0026#34;, StackProps.builder() .build()); Tạo Evirontment bằng đoạn code Environment environment = Environment.builder() .account(\u0026#34;your_account_id\u0026#34;) .region(\u0026#34;ap-southeast-1\u0026#34;) .build(); Với account là Account ID của tài khoản AWS của bạn Với region là region bạn muốn tạo resource ở đây chúng ta sẽ chọn ap-southeast-1 Thêm Evirontment vào ECRStack bằng đoạn code .env(environment) Tạo thuộc tính infraTags cho Tags Map\u0026lt;String, String\u0026gt; infraTags = new HashMap\u0026lt;\u0026gt;(); infraTags.put(\u0026#34;team\u0026#34;, \u0026#34;FirstCloudJourney\u0026#34;); infraTags.put(\u0026#34;cost\u0026#34;, \u0026#34;ECommerceInfra\u0026#34;); Thêm Tags cho ECRStack .tags(infraTags) Kiểm tra các stack mà CDK sẽ tạo cho cloudformation bằng lệnh cdk list ở đây CDK cho chúng ta thấy có 1 stack duy nhất đó là Ecr Để chuẩn bị môi trường triển khai cho các ứng dụng CDK trên AWS, bao gồm việc tạo các tài nguyên cần thiết để triển khai và quản lý các ứng dụng CDK một cách hiệu quả trên nền tảng AWS chúng ta cần chạy lệnh cdk bootstrap --profile default Để xem những gì chúng ta vừa toạ từ lệnh cdk bootstrap \u0026ndash;profile default truy cập vào AWS console nhập Cloudformation Trong giao diện Cloudformation, ta có thể thấy môt CDKToolkit vừ được tạo Chọn CDKToolkit và sau đó chọn resource tab để xem những resource đã được tạo "
},
{
	"uri": "//localhost:1313/vi/4-createvpc/4.2-orgaizestack/",
	"title": "Tổ chức và deploy VPC stack sử dụng AWS CDK",
	"tags": [],
	"description": "",
	"content": "Tổ chức VPC stack in CDK project Mở file root Fcj2024CdkApp Tạo VPC Stack với id là Vpc bằng đoạn code VpcStack vpcStack = new VpcStack(app, \u0026#34;Vpc\u0026#34;, StackProps.builder() .build()); Thêm environment và Tags Deploy VPC stack Bật termial và nhập lệnh ```cdk list`` để xem danh sách các task đang có. Ở đây ta có thể thấy Ecr và Vpc Tiếp theo nhập cdk deploy \u0026ndash;all để deploy tất cả stack. Khi được hỏi về những thay đổi policy. Nhập y Kiểm tra những thay đổi khi deploy. Ta có thể thấy rằng CDK nhận ra CER không đổi và chúng ta đang tạo một stack mới là VPC Kiểm tra resouce đã tạo trên aws console Truy cập vào aws console vào giao diện VPC và chọn Your VPCs. Ta có thể thấy ECommerceVPC đã được tạo Tương tự như vậy với Subnet,NAT gateway, security group\u0026hellip; "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.3-setupintellijidea/",
	"title": "Chuẩn bị IntelliJ IDEA",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị IntelliJ IDEA Dùng IntelliJ IDEA mở project spring boot vừa tạo Cài đặt project lick phải vào project chọn Open Module Settings Chọn Project Setting, hãy đảm bảo rằng project của bạn có SDK là 21 và language level là 21 Chọn Platform setting, hãy đảm bảo rằng platform SDK của bạn là 21 Chạy spring boot project Mở file application.properties thêm vào server.port=8081 để cấu hình project chạy trên port 8081 Nhấn vào biểu tượng Run để chạy project, bạn có thể thấy project đang chạy trên port 8081 Kiểm thử project trên postman Tạo request HTTP GET với đường dẫn http://localhost:8080/actuator/health để kiểm tra Reponse trả về \u0026ldquo;status\u0026rdquo;: \u0026ldquo;UP\u0026rdquo; chứng tỏ project hoạt đông bình thường Thêm thư viên Log4j2 Mở file build.grade Trong phần dependencies thêm thư viện Log4j2 bằng cách thêm đoạn mã sau implementation 'org.springframework.boot:spring-boot-starter-log4j2' Thêm configurations configurations { configureEach { exclude group: \u0026#39;org.springframework.boot\u0026#39;, module: \u0026#39;spring-boot-starter-logging\u0026#39; exclude group: \u0026#39;commons-logging\u0026#39;, module: \u0026#39;commons-logging\u0026#39; } } Tạo Controller Trong thư mục com.firstcloudjourney.productsservice tạo folder products Trong thư mục products tạo thư mục controllers và tạo file ProductsController.java từ thư mục controllers\nCopy đoạn code sau vào file ProductsController.java @RestController @RequestMapping(\u0026#34;/api/products\u0026#34;) public class ProductsController { private static final Logger LOG = LogManager.getLogger(ProductsController.class); @GetMapping public String getAllProducts() { LOG.info(\u0026#34;Get all products\u0026#34;); return \u0026#34;All products\u0026#34;; } } Chạy project và test trên postman bằng cách tạo request HTTP GET với đường dẫn http://localhost:8081/api/products Kiểm tra log trả về trên termnial khi gọi HTTP GET "
},
{
	"uri": "//localhost:1313/vi/3-createecr/",
	"title": "Tạo AWS ECR image repository bằng AWS CDK",
	"tags": [],
	"description": "",
	"content": "Trong phần này chúng ta sẽ tìm hiểu về cách tạo stack để triển khai ECR trên AWS\n"
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.3-createsericelogdriver/",
	"title": "Tạo Service Log Driver",
	"tags": [],
	"description": "",
	"content": "Tạo Service Log Driver Trong quá trình phát triển a spring boot application, chúng ta cần log để debug application do đó chúng ta cần sử dụng Log Group của CloudWatch\nĐể tạo log group, trước tiên ta cần khởi tạo đối tượng AwsLogDriver trong contructor\nAwsLogDriver logDriver = new AwsLogDriver(AwsLogDriverProps.builder() .build()); Khởi tạo đối tượng LogGroup trong AwsLogDriver .logGroup(new LogGroup(this, \u0026#34;LogGroup\u0026#34;, LogGroupProps.builder() .build())) Tiếp theo chúng ta cần thêm các thuộc tính cần thiết cho LogGroup Với tên cho groug log là ProductsService .logGroupName(\u0026#34;ProductsService\u0026#34;) Tiếp theo cho ta sẽ cấu hình xoá log group khi delete Stack .removalPolicy(RemovalPolicy.DESTROY) Cuối cùng cho ta sẽ cho AWS biết là sẽ giữ những log này trong bao lâu. Ỡ đâu chúng ta sẽ giữ 1 tháng .retention(RetentionDays.ONE_MONTH) Cuối cùng chúng tao cần tạo prefix cho file của chúng ta .streamPrefix(\u0026#34;ProductsService\u0026#34;) "
},
{
	"uri": "//localhost:1313/vi/5-createecs/5.3-createvpclink/",
	"title": "Tạo VPC Link",
	"tags": [],
	"description": "",
	"content": "Tạo VPC link Để tạo VPC link chúng ta cần khởi tạo đối tượng vpcLink đã khai báo trước đó this.vpcLink = new VpcLink(this, \u0026#34;VpcLink\u0026#34;, VpcLinkProps.builder() .build()); Tiếp theo chúng ta sẽ kết nối PVC Link với Network Load Balancer tạo 1 target cho .targets(Collections.singletonList(this.networkLoadBalancer)) "
},
{
	"uri": "//localhost:1313/vi/3-createecr/3.3-implementstack/",
	"title": "Triển khai Stack lên AWS ECR",
	"tags": [],
	"description": "",
	"content": "Triển khai Stack lên AWS ECR Để triển khia stak lên AWS ECR chúng ta nhập ```cdk deploy Ecr \u0026ndash;profile default`` Trong quá trình tạo resource, có vài câu hỏi về security policy chúng ta cần thay đổi. Nhập y Tạo ECR thành công Truy cập vào AWS console nhập ECR và chọn Elastic Container Registry Ta có thể thấy repository productsservice đã được tạo "
},
{
	"uri": "//localhost:1313/vi/3-createecr/3.4-pushimage/",
	"title": "Push Docker image lên ECR",
	"tags": [],
	"description": "",
	"content": "Push Docker image lên ECR repository Hãy đảm bảo là bạn đã cài AWS toolkit. Nếu chưa vào IntelliJ IDEA setting chọn plugins và tìm AWS toolkit để cài đặt Chọn biểu tưởng AWS toolkit bên phải phần mềm IntelliJ IDEA Chọn profile và region Với profile chọn defautl Region chọn ap-southeast-1 Chọn Exploxer để xem tất cả dịch vụ AWS toolkit hỗ trợ sau đó chọn ECR Ta có thể thấy có 2 repository chúng ta sẽ push docker image lên productsservice repository bằng cách lick phải vào productsservice và chọn push to Repository\u0026hellip; Pop up Push to ECR hiện lên Với local image chọn productsservice:1.0.0 Với ECR Repository chọn productsservice Với Remote Tag nhập 1.0.0 Cuối cùng chọn Push Kiểm tra image trên ECR Trong giao diện AWS console truy cập vào ECR Chọn productsservice Repository ta có thể thấy docker image phiên bản 1.0.0 đã được push lên "
},
{
	"uri": "//localhost:1313/vi/5-createecs/5.4-createalb/",
	"title": "Tạo Application Load Balancer",
	"tags": [],
	"description": "",
	"content": "Tạo Application Load Balancer Trước tiên chúng ta sẽ tạo Application Load Balancer (NLB). Để tạo SLB chúng ta cần khởi tạo đối tượng applicationLoadBalancer trong contructor this.applicationLoadBalancer = new ApplicationLoadBalancer(this, \u0026#34;Alb\u0026#34;, ApplicationLoadBalancerProps.builder() .build()); Tiếp theo đặt tên cho NLB là ECommerceNlb bằng cách .loadBalancerName(\u0026#34;ECommerceAlb\u0026#34;) Như đã để cập trước đó. Chúng ta sẽ khổng để NLB và ALB ngoài VPC nên chúng ta sẽ làm như sau .internetFacing(false) .vpc(nlbStackProps.vpc()) "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.4-createdockerfile/",
	"title": "Tạo Dockerfile và generate docker image",
	"tags": [],
	"description": "",
	"content": "Tạo task Trước tiên bạn cần phải tạo task trên file build.grade bằng cách copy đoạn code sau tasks.register(\u0026#34;unpack\u0026#34;, Copy) { dependsOn bootJar from(zipTree(tasks.bootJar.outputs.files.singleFile)) into(\u0026#34;build/libs\u0026#34;) } Đoạn mã này là một đoạn mã sử dụng Gradle để định nghĩa một task mới có tên là \u0026ldquo;unpack\u0026rdquo;. Hành động của task này là sao chép (copy) các file từ một tệp nén (ZIP) của task \u0026ldquo;bootJar\u0026rdquo; và giải nén chúng vào thư mục \u0026ldquo;build/libs\u0026rdquo;.\nTạo file .dockerignore Tạo file .dockerignore để chỉ định những file và thư mục mà Docker sẽ bỏ qua (ignore) khi bạn đóng gói (build) một image Docker từ các thành phần của project. Copy đoạn code bên dưới .git .gitignore .dockerignore .gradle .idea Dockerfile README.md Tạo file Dockerfile Tạo file Dockerfile và copy đoạn code bên dưới FROM eclipse-temurin:21-jdk-alpine VOLUME /tmp ARG DEPENDENCY=build/libs COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib COPY ${DEPENDENCY}/META-INF /app/META-INF COPY ${DEPENDENCY}/BOOT-INF/classes /app EXPOSE 8081 ENTRYPOINT [\u0026#34;java\u0026#34;, \u0026#34;-cp\u0026#34;, \u0026#34;app:app/lib/*\u0026#34;, \u0026#34;com.firstcloudjourney.productsservice.ProductsserviceApplication\u0026#34;] Generate docker image Tiếp theo chúng ta sẽ cấu hình trên intelliJ để generate Docker image Nhấn vào biểu tượng Run, chọn new run configuration Một popup hiện lên chúng ta sẽ cấu hình như sau Với Image Tag, nhập productsservice:1.0.0 Nhấn Modify Opition chọn Build options Khi Build options hiên ra, nhập --platform linux/amd64 Tiếp theo chúng ta cần cấu hình before launch Nhấn vào icon + và chọn run gradle task Sau đó 1 pop up hiên lên như bên dưới Trong pop up select gradle task Với Gradle project chọn productsservice Với Task chọn unpack task chúng ta đã thêm trước đó Chọn Ok Sau khi trở lại pop up edit configuration nhấn apply build ứng dụng sử dụng bootjar Tiếp theo chúng ta sẽ build ứng dụng bằng cách sử dụng bootjar từ gradle Chọn biểu tượng gradle Chọn task theo sau đó là build và nhấn bootjar để build ứng dụng Kiểm tra file ứng dụng chúng ta đã buid theo đường dẫn build/libs Gennerate docker image Bây giờ chúng ta sẽ tạo Docker image từ ứng dụng chúng ta đã build Nhấn vào biểu tượng Run ở DockerFile và chọn Build image for \u0026lsquo;DockerFile\u0026rsquo; Hãy đảm bảo bạn đã mở docker desktop để có thể build image thành công\nSau khi tạo image thành công chúng ta có thể thấy productsservice:1.0.0 đã được tạo ra "
},
{
	"uri": "//localhost:1313/vi/4-createvpc/",
	"title": "Tạo VPC và Nat gateway bằng cách sử dụng AWS CDK",
	"tags": [],
	"description": "",
	"content": "Trong phần này chúng ta sẽ tạo VPC và Nat gateway bằng cách sử dụng AWS CDK\n"
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.4-addservicetotask/",
	"title": "Thêm container service vào task definition",
	"tags": [],
	"description": "",
	"content": "Thêm container service vào task definition Để thêm container phương thức addContainer của fargateTaskDefinition đã khởi tạo trước đó fargateTaskDefinition.addContainer() Thêm id là ProductsServiceContainer và tạo ContainerDefinitionOptions fargateTaskDefinition.addContainer(\u0026#34;ProductsServiceContainer\u0026#34;, ContainerDefinitionOptions.builder() .build()); Thêm image từ ECR Repository với phiên bản 1.0.0 chúng ta đã tạo trước đó .image(ContainerImage.fromEcrRepository(productsServiceProps.repository(), \u0026#34;1.0.0\u0026#34;)) Tiếp theo ta cần đặt tên cho Container và là thêm logDriver đã tạo trước đó .containerName(\u0026#34;productsService\u0026#34;) .logging(logDriver) Bời vì ứng dụng của chúng ta sử dũng port 8081, do đó chúng ta cần thêm port cho container service .portMappings(Collections.singletonList(PortMapping.builder() .containerPort(8081) .protocol(Protocol.TCP) .build())) Tiếp theo chúng ta cần tạo environtment. Giá trị của nó là một Map\u0026lt;String, String\u0026gt; Trước tiên chúng ta cần khai báo 1 biến envVariables Map\u0026lt;String, String\u0026gt; envVariables = new HashMap\u0026lt;\u0026gt;(); envVariables.put(\u0026#34;SERVER_PORT\u0026#34;, \u0026#34;8081\u0026#34;); Tiếp theo thêm environment cho service container .environment(envVariables) "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.5-rundockerlocal/",
	"title": "Chạy Docker image trên máy local",
	"tags": [],
	"description": "",
	"content": "Chạy Docker image trên máy local Nhấp chuột phải vào image productsservice:1.0.0 chúng ta đã tạo trước đó và chọn Create Container. Pop up Docker image configuration hiện lên chúng ta chọn Run và terminal sẽ run Cấu hình docker container Trong giao diên services chọn tab Dashboard và sau đó chọn add Ports Popup Port bindings hiện lên ta chọn modify options chọn Host IP Nhập 0.0.0.0 vào Host IP Tương tự như trên lần lượt cấu hình host port là 8081 và protocol là TCP Với \u0026ndash;publish nhập 8081 và chọn Recreate container\nTest ứng dụng trên postman Chạy project và test trên postman bằng cách tạo request HTTP GET với đường dẫn http://localhost:8081/api/products "
},
{
	"uri": "//localhost:1313/vi/5-createecs/",
	"title": "Tạo ECS bằng cách sử dụng AWS CDK",
	"tags": [],
	"description": "",
	"content": "Trong phần này chúng ta sẽ tạo ECS cluster, ECS infrastructure và ECS service "
},
{
	"uri": "//localhost:1313/vi/5-createecs/5.5-organizeanddeploystack/",
	"title": "Tổ chức và deploy NLB Stack",
	"tags": [],
	"description": "",
	"content": "Tổ chức và deploy NLB Stack Mở file root Fcj2024CdkApp Tạo NLB Stack với id là Nlb bằng đoạn code NlbStack nlbStack = new NlbStack(app, \u0026#34;Nlb\u0026#34;, StackProps.builder() .build(),); Truyền VPC đã tạo trước đó cho ClusterStackProps của ECS stack new NlbStackProps(vpcStack.getVpc()) Thêm Thêm environmen* và Tags cho NLB Stack .env(environment) .tags(infraTags) Vì NLB cần có VPC để tạo. Hãy thêm phụ thuộc để đảm bảo rằng VPC được tạo hoàn thành trước khi tạo NLB nlbStack.addDependency(vpcStack); Deloy NLB bằng AWS CDK Deploy NLB bằng AWS CDK cdk deploy --all --require-approval never Kiểm ta AWS resource đã tạo Trong giao diện AWS console nhập EC2 Trong giao diện EC2 chọn Load balancers ta có thể thấy NLB và ALB đã được tạo Trong giao diện EC2. Nhập API gateway vào than tìm kiếm và chọn API Gateway Trong gia diện API Gateway chọn VPC links ta có thể thấy VPC link đã được tạo thành công "
},
{
	"uri": "//localhost:1313/vi/6-createservice/",
	"title": "Tạo ECS service với CDK",
	"tags": [],
	"description": "",
	"content": "Trong phần này chúng ta sẽ tạo ECS Service bằng CDK. Trong workshop này chúng ta sẽ tạo ProductService "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.5-addlistenteralb/",
	"title": "Thêm Listener vào Application Load Balancer",
	"tags": [],
	"description": "",
	"content": "Thêm Listener vào Application Load Balancer Khởi tạo ApplicationListener ApplicationListener applicationListener = productsServiceProps.applicationLoadBalancer() Thêm 1 listener với id là ProductsServiceAlbListener và khởi tạo ApplicationListenerProps .addListener(\u0026#34;ProductsServiceAlbListener\u0026#34;, ApplicationListenerProps.builder() .build()); Tiếp theo cho ta sẽ cho ALB listener trên port 8081 và sử dụng giao thức HTTP .port(8081) .protocol(ApplicationProtocol.HTTP) Cuối cùng thêm applicationListener vào Application Load Balancer .loadBalancer(productsServiceProps.applicationLoadBalancer()) "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.7-createfagateservice/",
	"title": "Tạo AWS Fargate service",
	"tags": [],
	"description": "",
	"content": "Tạo AWS Fargate service Khởi tạo FargateService trong ProductsServiceStack contructor với id là ProductsService FargateService fargateService = new FargateService(this, \u0026#34;ProductsService\u0026#34;, FargateServiceProps.builder() .build()); Thêm service name là ProductsService .serviceName(\u0026#34;ProductsService\u0026#34;) Tiếp theo chúng ta cần thêm cluster đã tạo trước đó để tạo fargate service .cluster(productsServiceProps.cluster()) Ngoài cluster, chúng ta cần có task definition để tạo fragate. Chúng ta sẽ dùng fargateTaskDefinition đã tạo bên trên .taskDefinition(fargateTaskDefinition) Tiếp theo chúng ta sẽ khai báo bao nhiêu instance chúng ta muốn sử dụng. Trong workshop này chúng ta sẽ dử dụng 2 .desiredCount(2) Tiếp theo để giữ fargate trong private subnet nối bên ngoài thông qua NAT Gateway chúng ta sẻ không thêm public IP .assignPublicIp(false) Ngoài ra nếu trong phần tạo PVC bạn không tạo NAT Gateway, bạn có thể làm như sau .assignPublicIp(true) Đừng làm trong môi trường production\nECS service của chúng ta cần permission để pull image từ ECR repository. Vì vậy chúng ta cần phải cấp quyền như sau productsServiceProps.repository().grantPull(Objects.requireNonNull(fargateTaskDefinition.getExecutionRole())); Cuối cùng 1 đều quan trọng nữa là chúng ta cần định nghĩa là service của chúng ta chấp nhận requests từ http port 8081 fargateService.getConnections().getSecurityGroups().get(0).addIngressRule(Peer.anyIpv4(), Port.tcp(8081)); "
},
{
	"uri": "//localhost:1313/vi/6-createservice/6.8-configtargergroup/",
	"title": "Cấu hình AWS ALB Target group và cơ chế health check",
	"tags": [],
	"description": "",
	"content": "Cầu hình AWS ALB Target group và cơ chế health check Trước tiên tạo taget group từ applicationListener bằng phương thức .addTargets với ID là ProductsServiceAlbTarget applicationListener.addTargets(\u0026#34;ProductsServiceAlbTarget\u0026#34;, AddApplicationTargetsProps.builder() .build() ); Đặt tên cho target group là productsServiceAlb .targetGroupName(\u0026#34;productsServiceAlb\u0026#34;) Tiếp theo chúng ta sẽ tạo port 8001 để Load Balancer gửi traffic đến và dùng giao thức HTT để giao tiếp với các target .port(8081) .protocol(ApplicationProtocol.HTTP) Tiếp thep ta cần thêm danh sách các service Fargate vào target .targets(Collections.singletonList(fargateService)) Tiếp theo chúng ta sẽ định nghĩa độ trễ cho phép là 30 giây trước khi Load Balancer hủy bỏ một target khi nó bị đánh dấu là không khả dụng .deregistrationDelay(Duration.seconds(30)) Tiếp theo chúng ta sẽ cấu hình health check và bât tính năng health check để đảm bảo rằng các target đang hoạt động đúng cách. .healthCheck(HealthCheck.builder() .enabled(true) .build()) Kế tiếp chúng ta sẽ cấu hình khoảng thời gian giữa các lần kiểm tra sức khỏe là 30 giây và thời gian tối đa để chờ đợi phản hồi từ một target trong mỗi lần kiểm tra là 10 giây .interval(Duration.seconds(30)) .timeout(Duration.seconds(10)) Cuối cùng chúng ta sẽ khai báo đường dẫn(endpoint) được sử dụng để kiểm tra sức khỏe của các target là /actuator/health và port 8081 được sử dụng trong health check để giao tiếp với các target "
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]